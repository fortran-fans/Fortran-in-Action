<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fortran语言实战</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> 关于</a></li><li class="chapter-item expanded "><a href="Fortran-Best-Practices/introduction.html"><strong aria-hidden="true">2.</strong> Fortran最佳实践</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Fortran-Best-Practices/fortran-style-guide.html"><strong aria-hidden="true">2.1.</strong> Fortran风格指导</a></li><li class="chapter-item expanded "><a href="Fortran-Best-Practices/floating-point-numbers.html"><strong aria-hidden="true">2.2.</strong> 浮点数</a></li><li class="chapter-item expanded "><a href="Fortran-Best-Practices/integer-division.html"><strong aria-hidden="true">2.3.</strong> 整数除法</a></li><li class="chapter-item expanded "><a href="Fortran-Best-Practices/modules-programs.html"><strong aria-hidden="true">2.4.</strong> 模块</a></li><li class="chapter-item expanded "><a href="Fortran-Best-Practices/arrays.html"><strong aria-hidden="true">2.5.</strong> 数组</a></li><li class="chapter-item expanded "><a href="Fortran-Best-Practices/multidim-arrays.html"><strong aria-hidden="true">2.6.</strong> 高维数组</a></li><li class="chapter-item expanded "><a href="Fortran-Best-Practices/element-operation.html"><strong aria-hidden="true">2.7.</strong> 逐元操作</a></li><li class="chapter-item expanded "><a href="Fortran-Best-Practices/allocatable-arrays.html"><strong aria-hidden="true">2.8.</strong> 可分配数组</a></li><li class="chapter-item expanded "><a href="Fortran-Best-Practices/file-io.html"><strong aria-hidden="true">2.9.</strong> 文件io</a></li><li class="chapter-item expanded "><a href="Fortran-Best-Practices/callbacks.html"><strong aria-hidden="true">2.10.</strong> 回调函数</a></li><li class="chapter-item expanded "><a href="Fortran-Best-Practices/type-casting.html"><strong aria-hidden="true">2.11.</strong> 类型转换</a></li><li class="chapter-item expanded "><a href="Fortran-Best-Practices/bug-trap.html"><strong aria-hidden="true">2.12.</strong> 陷阱或缺陷</a></li></ol></li><li class="chapter-item expanded "><a href="Fortran-Programming-in-Windows/index.html"><strong aria-hidden="true">3.</strong> 在Windows系统下进行Fortran编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Fortran-Programming-in-Windows/Path-in-Windows.html"><strong aria-hidden="true">3.1.</strong> 环境路径</a></li><li class="chapter-item expanded "><a href="Fortran-Programming-in-Windows/use-GFortran-in-Windows.html"><strong aria-hidden="true">3.2.</strong> 使用GFortran</a></li><li class="chapter-item expanded "><a href="Fortran-Programming-in-Windows/use-OneAPI-in-Windows.html"><strong aria-hidden="true">3.3.</strong> 使用OneAPI套件</a></li></ol></li><li class="chapter-item expanded "><a href="Using-Open-Source-Code/index.html"><strong aria-hidden="true">4.</strong> 拥抱开源，高效使用现代Fortran</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Using-Open-Source-Code/Project-Configuration-TOML-F.html"><strong aria-hidden="true">4.1.</strong> 为程序设置配置文件：TOML</a></li><li class="chapter-item expanded "><a href="Using-Open-Source-Code/Matrix-Calculation-OpenBLAS.html"><strong aria-hidden="true">4.2.</strong> 使用OpenBLAS进行矩阵计算</a></li><li class="chapter-item expanded "><a href="Using-Open-Source-Code/Colorful-Console.html"><strong aria-hidden="true">4.3.</strong> 使用M_attr输出彩色控制台文本</a></li><li class="chapter-item expanded "><a href="Using-Open-Source-Code/Test-Your-Code.html"><strong aria-hidden="true">4.4.</strong> 使用test-drive测试你的代码</a></li><li class="chapter-item expanded "><a href="Using-Open-Source-Code/Fortran-Hot-reload-Powered-By-Lua.html"><strong aria-hidden="true">4.5.</strong> 使用 Lua 语言及其脚本实现 Fortran 程序的热重载</a></li></ol></li><li class="chapter-item expanded "><a href="Fortran-Developer-Tools/index.html"><strong aria-hidden="true">5.</strong> Fortran开发者编程工具集</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Fortran-Developer-Tools/Fprettify.html"><strong aria-hidden="true">5.1.</strong> 使用 Fprettify 格式化你的代码</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Fortran语言实战</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/fortran-fans/Fortran-in-Action/tree/main/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fortran语言实战"><a class="header" href="#fortran语言实战">Fortran语言实战</a></h1>
<p><a href="LICENSE"><img src="https://img.shields.io/github/license/fortran-fans/Fortran-in-Action?color=pink" alt="MIT" /></a>
<a href="https://github.com/fortran-fans/Fortran-in-Action/actions"><img src="https://github.com/fortran-fans/Fortran-in-Action/workflows/mdbook/badge.svg" alt="Actions Status" /></a></p>
<p>《Fortran语言实战》是一份由Fortran爱好者（Fortran-Fans）社区驱动的Fortran语言编程实战教程。</p>
<p><strong>呼吁：</strong><em>我们需要你们的帮助，欢迎你们为我们贡献教程，促成国内 Fortran 最新教程、信息的繁荣。</em></p>
<table><thead><tr><th align="center">项目</th><th align="center">描述</th></tr></thead><tbody>
<tr><td align="center">版本：</td><td align="center">0.0.2</td></tr>
<tr><td align="center">作者：</td><td align="center">Fortran爱好者（Fortran-Fans）</td></tr>
<tr><td align="center">网页：</td><td align="center">https://fortran-fans.github.io/Fortran-in-Action/</td></tr>
<tr><td align="center">版权：</td><td align="center">Copyright (c) 2021 Fortran-Fans</td></tr>
</tbody></table>
<h2 id="开始"><a class="header" href="#开始">开始</a></h2>
<h3 id="软件依赖"><a class="header" href="#软件依赖">软件依赖</a></h3>
<ul>
<li>Git</li>
<li><a href="https://www.rust-lang.org/zh-CN/">Rust</a>（可选，用于构建 MDBook）</li>
<li><a href="https://github.com/rust-lang/mdBook">mdbook</a>（可选，用于构建 MDBook）</li>
</ul>
<h3 id="获取代码"><a class="header" href="#获取代码">获取代码</a></h3>
<pre><code class="language-sh">git clone https://github.com/fortran-fans/Fortran-in-Action.git
cd Fortran-in-Action
</code></pre>
<h3 id="使用a-hrefhttpsgithubcomrust-langmdbookmdbooka构建文档"><a class="header" href="#使用a-hrefhttpsgithubcomrust-langmdbookmdbooka构建文档">使用<a href="https://github.com/rust-lang/mdBook">mdbook</a>构建文档</a></h3>
<p>mdBook是一个从Markdown文件创建现代在线书籍的实用程序。<br>
你可以通过提供的<code>book.toml</code>文件来构建《Fortran语言实战》。</p>
<pre><code>mdbook build
</code></pre>
<h2 id="链接"><a class="header" href="#链接">链接</a></h2>
<ul>
<li><a href="https://fortran-lang.org/learn/best_practices">Fortran Best Practices</a><br>
《Fortran最佳实践》是Fortran-Lang官网的mini-book，等待Fortran-Lang官网的国际化进程推进，本教程该部分内容将回馈<a href="https://github.com/fortran-lang/fortran-lang.org">Fortran-Lang官网</a>。</li>
<li><a href="https://github.com/rust-lang/mdBook">rust-lang/mdBook</a></li>
</ul>
<h2 id="开源许可证"><a class="header" href="#开源许可证">开源许可证</a></h2>
<p>MIT License</p>
<p>Copyright (c) 2021 Fortran Fans</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关于本书fortran最佳实践"><a class="header" href="#关于本书fortran最佳实践">关于本书（《Fortran最佳实践》）</a></h1>
<p>作者：Ondřej Čertík、John Pask、Jed Brown、Matthew Emmett、Juan Luis Cano Rodríguez、Neil Carlson、Andrea Vigliotti、Pierre Haessig、Vincent Magnin、Sebastian Ehlert、Jeremie Vandenplas</p>
<p>此书收集了一些现代且规范编写Fortran的方法，将针对常见的话题和任务进行代码风格指导，以及推荐最佳实践方法。总而言之，它会列举和讨论一些规范的解决方案和模式。这本书主要面向已经对Fortran语法和编写有基本了解的编程者。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fortran风格指导"><a class="header" href="#fortran风格指导">Fortran风格指导</a></h1>
<h2 id="命名规则"><a class="header" href="#命名规则">命名规则</a></h2>
<p>虽然如何命名取决于个人偏好，但是我们在这里给出一份我们喜欢的，
并且在很多科学计算代码（以及Fortran standard library）中流行的风格。欢迎你也使用这一风格。</p>
<ol>
<li>在所有Fortran结构中使用小写字母（<code>do</code>、<code>subroutine</code>、<code>module</code>……）</li>
<li>对于数学变量/函数使用简短的数学上的记号（<code>Ylm</code>、<code>Gamma</code>、<code>gamma</code>、<code>Enl</code>、<code>Rnl</code>……）</li>
<li>其他的名字全部都用小写字母：尽量让名字为一到两个音节；
如果需要更多音节，则用下划线使其看着清晰（<code>sortpair</code>、<code>whitechar</code>、<code>meshexp</code>、<code>numstrings</code>、<code>linspace</code>、
<code>meshgrid</code>、<code>argsort</code>、<code>spline</code>、<code>spline_interp</code>、<code>spline_interpolate</code>、<code>stoperr</code>、<code>stop_error</code>、<code>meshexp_der</code>）</li>
</ol>
<p>例如“spline interpolation”可以缩短为<code>spline_interpolation</code>、<code>spline_interpolate</code>、<code>spline_interp</code>、<code>spline</code>，
但不是<code>splineint</code>（“int”可能表示积分、整数等。——太多的歧义，即使在清晰的计算代码上下文中）。
这与 <code>get_argument()</code> 形成对比，这时表达为<code>getarg()</code> 非常整洁明了。</p>
<p>以上是一般性准则。一般来说，选择正确的名字主要取决于，被截断的单词取第一个音节是否足够。显然，通常情况并非如此。
因此，需要考虑下一步“尽量报持名称在2个音节或更少”，因为这确实可以影响表意和简单性。
简单且一致的命名规则在以下情况起到很大的帮助——与别人协作编码，或回顾自己有较长时间没有关注过的历史代码。</p>
<h2 id="缩进"><a class="header" href="#缩进">缩进</a></h2>
<p>使用一致的缩进使您的代码可读。缩进的数量是一个个人偏好的问题，最常见的选择是两个、三个或四个空格。</p>
<h2 id="与其他语言的比较"><a class="header" href="#与其他语言的比较">与其他语言的比较</a></h2>
<p>另一方面，在其它的、大部分的编程世界，主要重点是以这样或那样的形式定义和使用大量复杂对象，
其中有数以“吨”计的属性和行为，仅在定义它们的代码位置处才能知道（而不是在整个文档中使用相同的符号定义），
使用更长、更具描述性的命名更有意义。因此，人们看到在更通用的编程语言（如C++和Python）中使用的命名约定
与它们更通用的任务保持完全一致。但是Fortran有不同的使命（数值科学计算）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="浮点数"><a class="header" href="#浮点数">浮点数</a></h1>
<p>浮点数的默认表示形式是使用单精度（通常为32位/4字节）。对于大多数程序而言，需要更高的精度。
为此，可以自定义种类（kind）参数。我们推荐使用如下方式定义种类参数</p>
<pre><code class="language-fortran">integer, parameter :: dp = selected_real_kind(15)
</code></pre>
<p>在很多情景下，通过字面值常量推导得到种类参数也足以满足需求</p>
<pre><code class="language-fortran">integer, parameter :: dp = kind(0.0d0)
</code></pre>
<p>或将<code>iso_fortran_env</code>内置模块中导入的种类参数重命名，</p>
<pre><code class="language-fortran">use, intrinsic :: iso_fortran_env, only : dp =&gt; real64
</code></pre>
<p>有关种类参数的一些深刻的见解，请看
<a href="https://web.archive.org/web/20200930090137/https://stevelionel.com/drfortran/2017/03/27/doctor-fortran-in-it-takes-all-kinds/">Doctor Fortran in it takes all KINDs</a>.</p>
<p>我们建议构建一个核心模块来定义种类参数，并在必要时引入它们。
在此，给出此类模块的示例，</p>
<pre><code class="language-fortran">!&gt; Numerical storage size parameters for real and integer values
module kind_parameter
   implicit none
   public

   !&gt; Single precision real numbers, 6 digits, range 10⁻³⁷ to 10³⁷-1; 32 bits
   integer, parameter :: sp = selected_real_kind(6, 37)
   !&gt; Double precision real numbers, 15 digits, range 10⁻³⁰⁷ to 10³⁰⁷-1; 64 bits
   integer, parameter :: dp = selected_real_kind(15, 307)
   !&gt; Quadruple precision real numbers, 33 digits, range 10⁻⁴⁹³¹ to 10⁴⁹³¹-1; 128 bits
   integer, parameter :: qp = selected_real_kind(33, 4931)

   !&gt; Char length for integers, range -2⁷ to 2⁷-1; 8 bits
   integer, parameter :: i1 = selected_int_kind(2)
   !&gt; Short length for integers, range -2¹⁵ to 2¹⁵-1; 16 bits
   integer, parameter :: i2 = selected_int_kind(4)
   !&gt; Length of default integers, range -2³¹ to 2³¹-1; 32 bits
   integer, parameter :: i4 = selected_int_kind(9)
   !&gt; Long length for integers, range -2⁶³ to 2⁶³-1; 64 bits
   integer, parameter :: i8 = selected_int_kind(18)

end module kind_parameter
</code></pre>
<p>声明浮点常量，应始终写出种类参数后缀，</p>
<pre><code class="language-fortran">real(dp) :: a, b, c
a = 1.0_dp
b = 3.5_dp
c = 1.34e8_dp
</code></pre>
<p>将整数赋值给浮点数（不超过有效数字限制的整数）是安全的，不会丢失精度。</p>
<pre><code class="language-fortran">real(dp) :: a
a = 3
</code></pre>
<p>为了强制使用浮点除法（与整数除法<code>3/4==0</code>不同），可以通过以下方式将整数转换为浮点数，</p>
<pre><code class="language-fortran">real(dp) :: a
a = real(3, dp) / 4  ! 'a' is equal to 0.75_dp
</code></pre>
<p>或者简单地用乘以<code>1.0_dp</code>的乘法分隔整数除法。</p>
<p>要在不丢失精度的情况下打印浮点数，使用无限制格式<code>&quot;(g0)&quot;</code>或指数表示法<code>&quot;(es24.16e3)&quot;</code>，会提供17位有效数字的打印输出。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整数除法"><a class="header" href="#整数除法">整数除法</a></h1>
<p>Fortran区分浮点运算和整数运算。需要注意的是，整数除法总是使用整数算术。
此外，虽然Fortran使用标准的运算顺序（例如，在没有括号的情况下，乘除法优先级高于加减法），
但相同优先级的运算是从左到右计算的。
如下，考虑一个奇数做整数除法的例子。</p>
<pre><code class="language-fortran">integer :: n
n = 3
print *, n / 2  ! prints 1
print *, n*(n + 1)/2  ! prints 6
print *, n/2*(n + 1)  ! prints 4 (left-to-right evaluation order)
n = -3
print *, n / 2  ! prints -1
</code></pre>
<p>在实际情况中，请注意你是否真的需要使用整数算术。
如果要改用浮点算术，请确保在使用除法运算符之前强制转换为实数，或通过乘以<code>1.0_dp</code>来分隔整数。</p>
<pre><code class="language-fortran">integer :: n
n = 3
print *, real(n, dp) / 2  ! prints 1.5
print *, n * 1.0_dp / 2  ! prints 1.5
n = -3
print *, real(n, dp) / 2  ! prints -1.5
print *, n * 1.0_dp / 2  ! prints -1.5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块和程序"><a class="header" href="#模块和程序">模块和程序</a></h1>
<p>模块（<code>module</code>）是创建现代Fortran库和应用程序的首选方法。
按照惯例，一个源文件应始终只包含一个模块，而模块名称应与文件路径匹配，以便在较大的项目中可以轻松浏览。
此外还建议在模块名前加上库名，以避免在其他项目中作为依赖项使用时发生名称冲突。
这里给出了一个模块文件的示例，</p>
<pre><code class="language-fortran">!&gt; Interface to TOML processing library.
!&gt;
!&gt; ...
module fpm_toml
  use fpm_error, only : error_t, fatal_error, file_not_found_error
  use fpm_strings, only : string_t
  use tomlf, only : toml_table, toml_array, toml_key, toml_stat, get_value, &amp;
    &amp; set_value, toml_parse, toml_error, new_table, add_table, add_array, &amp;
    &amp; toml_serializer, len
  implicit none
  private

  public :: read_package_file
  public :: toml_table, toml_array, toml_key, toml_stat, get_value, set_value
  public :: new_table, add_table, add_array, len
  public :: toml_error, toml_serializer, toml_parse

contains

  !&gt; Process the configuration file to a TOML data structure
  subroutine read_package_file(table, manifest, error)
    !&gt; TOML data structure
    type(toml_table), allocatable, intent(out) :: table
    !&gt; Name of the package configuration file
    character(len=*), intent(in) :: manifest
    !&gt; Error status of the operation
    type(error_t), allocatable, intent(out) :: error
    ! ...
  end subroutine read_package_file

end module fpm_toml
</code></pre>
<p>本示例模块中有几点需要强调。
首先，每个模块都以注释开始，记录模块的目的和内容。
类似的，每个过程都以一条注释开始，简要描述其目的和虚参的意义。
无论使用何种语言，文档都是创建长期软件的最重要部分之一。</p>
<p>其次，显式地导入<code>use</code>和导出<code>public</code>，通过浏览模块的源代码来检查已经使用的和可用的过程、常量和派生类型。
导入通常应限于模块范围，而不是在每个过程或接口范围中重新导入。
类似的，通过在一行上添加<code>private</code>语句并在<code>public</code>语句中显式列出所有导出符号，可以显式地进行导出。</p>
<p>最后，<code>implicit none</code>语句在整个模块生效，不需要在每个过程中重复使用它。</p>
<p>模块中的变量是静态的（<em>默认save属性</em>）。
强烈建议将模块变量的使用限制为常量表达式，比如只使用常数或枚举对象，或者将它们导出设置为<code>protected</code>而不是<code>public</code>。</p>
<p>在Fortran程序中，子模块（<code>submodule</code>）可以用来打破长依赖链，缩短重新编译的时间。
它们使得我们在不使用预处理器的情况下，提供专用化和经过优化的程序实现。</p>
<p>如下示例是Fortran标准库<a href="https://github.com/fortran-lang/stdlib">stdlib</a>中的积分模块，
此处只定义了模块过程的接口，而没有实现。</p>
<pre><code class="language-fortran">!&gt; Numerical integration
!&gt;
!&gt; ...
module stdlib_quadrature
  use stdlib_kinds, only: sp, dp, qp
  implicit none
  private

  public :: trapz
  ! ...

  !&gt; Integrates sampled values using trapezoidal rule
  interface trapz
    pure module function trapz_dx_dp(y, dx) result(integral)
      real(dp), intent(in) :: y(:)
      real(dp), intent(in) :: dx
      real(dp) :: integral
    end function trapz_dx_dp
    module function trapz_x_dp(y, x) result(integral)
      real(dp), intent(in) :: y(:)
      real(dp), intent(in) :: x(:)
      real(dp) :: integral
    end function trapz_x_dp
  end interface trapz

  ! ...
end module stdlib_quadrature
</code></pre>
<p>具体实现是在单独的子模块中提供的，比如这里给出的梯形积分规则。</p>
<pre><code class="language-fortran">!&gt; Actual implementation of the trapezoidal integration rule
!&gt;
!&gt; ...
submodule (stdlib_quadrature) stdlib_quadrature_trapz
  use stdlib_error, only: check
  implicit none

contains

  pure module function trapz_dx_dp(y, dx) result(integral)
    real(dp), intent(in) :: y(:)
    real(dp), intent(in) :: dx
    real(dp) :: integral
    integer :: n

    n = size(y)
    select case (n)
    case (0:1)
      integral = 0.0_dp
    case (2)
      integral = 0.5_dp*dx*(y(1) + y(2))
    case default
      integral = dx*(sum(y(2:n-1)) + 0.5_dp*(y(1) + y(n)))
    end select
  end function trapz_dx_dp

  ! ...
end submodule stdlib_quadrature_trapz
</code></pre>
<p>请注意，模块过程不必在同一个子模块中实现，可以使用多个子模块来减少大型模块的编译负载。</p>
<p>最后，在构建程序时，推荐尽可能少地在程序主体内留下最终的实现。而通过从模块中复用代码实现，能使你写出可被复用的代码，并专注于将用户输入传递到库函数和库对象的程序单元。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<p>数组是Fortran的核心对象。动态大小数组的创建在<a href="Fortran-Best-Practices/./allocatable-arrays.html">可分配数组</a>中讨论.
将数组传递到过程有四种方式</p>
<ol>
<li><em>假定形状数组（assumed-shape arrays）</em> </li>
<li><em>假定维度数组（assumed-rank arrays）</em></li>
<li><em>显式形状数组（explicit-shape arrays）</em></li>
<li><em>假定大小数组（assumed-size arrays）</em></li>
</ol>
<p>将数组传递给过程的首选方法是<em>假定形状</em>数组。</p>
<pre><code class="language-fortran">subroutine f(r)
  real(dp), intent(out) :: r(:)
  integer :: n, i
  n = size(r)
  do i = 1, n
    r(i) = 1.0_dp / i**2
  end do
end subroutine f
</code></pre>
<p>高维数组也可以以类似的方式传递。</p>
<pre><code class="language-fortran">subroutine g(A)
  real(dp), intent(in) :: A(:, :)
  ...
end subroutine g
</code></pre>
<p>数组通过如下方式被简单地传入，</p>
<pre><code class="language-fortran">real(dp) :: r(5)
call f(r)
</code></pre>
<p>在这种情况下没有进行数组复制。这样做的好处是数组的形状和大小信息在编译时会自动传递和检查，在运行时可以可选的检查。
类似地，数组片段传递也可以不需要使用临时数组:</p>
<pre><code class="language-fortran">real(dp) :: r(10)
call f(r(1:10:2))
call f(r(2:10:2))
</code></pre>
<p>这应该是你在子例程中传递数组的默认方式。</p>
<p>避免将数组作为整片传递，因为这会模糊代码的实际意图:</p>
<pre><code class="language-fortran">real(dp) :: r(10)
call f(r(:))
</code></pre>
<p>如果要更加通用的将数组传递给过程，可以使用Fortran 2018标准中引入的<em>假定维度</em>功能</p>
<pre><code class="language-fortran">subroutine h(r)
  real(dp), intent(in) :: r(..)
  select rank(r)
  rank(1)
  ! ...
  rank(2)
  ! ...
  end select
end subroutine h
</code></pre>
<p>实际维度可以在运行时使用<code>select rank</code>结构来查询。 这可以很容易地创建更多的泛型函数来处理不同维度的数组。</p>
<p><em>显式形状</em>数组可以用于从函数返回数据，它们的大部分功能可以由<em>假定形状</em>和<em>假定维数</em>数组完成。
但由于它经常用于与C或遗留Fortran程序的接口，因此在这里简要讨论。</p>
<p>要使用<em>显示形状</em>数组，数组大小必须显式地作为虚参传递，如下例所示，</p>
<pre><code class="language-fortran">subroutine f(n, r)
  integer, intent(in) :: n
  real(dp), intent(out) :: r(n)
  integer :: i
  do i = 1, n
    r(i) = 1.0_dp / i**2
  end do
end subroutine f
</code></pre>
<p>对于高维数组，必须传递额外的索引。</p>
<pre><code class="language-fortran">subroutine g(m, n, A)
  integer, intent(in) :: m, n
  real(dp), intent(in) :: A(m, n)
  ...
end subroutine g
</code></pre>
<p>可以如下方式调用，</p>
<pre><code class="language-fortran">real(dp) :: r(5), s(3, 4)
call f(size(r), r)
call g(size(s, 1), size(s, 2), s)
</code></pre>
<p>注意，此处没有检查形状，因此以下是可能产生错误结果的合法代码:</p>
<pre><code class="language-fortran">real(dp) :: s(3, 4)
call g(size(s), 1, s)  ! s(12, 1) in g
call g(size(s, 2), size(s, 1), s)  ! s(4, 3) in g
</code></pre>
<p>在这种情况下，保留了内存布局，但数组的形状改变了。
此外，<em>显式形状</em>数组需要连续的内存，并且在通过非连续数组切片访问时,需要创建临时数组。</p>
<p>使用函数返回<em>显式形状</em>数组，</p>
<pre><code class="language-fortran">function f(n) result(r)
  integer, intent(in) :: n
  real(dp) :: r(n)
  integer :: i
  do i = 1, n
    r(i) = 1.0_dp / i**2
  end do
end function f
</code></pre>
<p>最后，还有<em>假定大小的</em>数组，它提供最少的编译时和运行时检查，经常可以在遗留代码中找到。
它应该避免和<em>假定形状</em>或<em>假定维度</em>数组一起使用。
一个<em>假定大小</em>数组的虚参被星号标识为最后一个维度，这将禁止许多数组内置函数的使用，如<code>size</code>或<code>shape</code>。</p>
<p>要检查<em>假定形状</em>数组的大小和形状是否正确，<code>size</code>和<code>shape</code>内部函数可用于查询这些属性，</p>
<pre><code class="language-fortran">if (size(r) /= 4) error stop &quot;Incorrect size of 'r'&quot;
if (any(shape(r) /= [2, 2])) error stop &quot;Incorrect shape of 'r'&quot;
</code></pre>
<p>注意，<code>size</code>返回所有维度的总大小,要获得特定维度的形状，请将第二个参数<code>dim</code>添加到函数中。</p>
<p>可以使用数组构造器初始化数组</p>
<pre><code class="language-fortran">integer :: r(5)
r = [1, 2, 3, 4, 5]
</code></pre>
<p>隐式do循环也可以在数组构造器中使用，</p>
<pre><code class="language-fortran">integer :: i
real(dp) :: r(5)
r = [(real(i**2, dp), i = 1, size(r))]
</code></pre>
<p>数组构造器要求数组的类型是相同的,可以在开头加上类型的名称来规定</p>
<pre><code class="language-fortran">real(8)::a(4)
complex(8)::b(4)
!a=[1.2d0,2,3,4]!错误
a=[real(8)::1.2d0,2,3,4]!正确
b=[complex(8)::1,2,(1.d0,2.d0),1.1d0]!正确
</code></pre>
<p>要使数组不以索引1开始，请执行以下操作：</p>
<pre><code class="language-fortran">subroutine print_eigenvalues(kappa_min, lam)
  integer, intent(in) :: kappa_min
  real(dp), intent(in) :: lam(kappa_min:)

  integer :: kappa
  do kappa = kappa_min, ubound(lam, 1)
    print *, kappa, lam(kappa)
  end do
end subroutine print_eigenvalues
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高维数组"><a class="header" href="#高维数组">高维数组</a></h1>
<p>多维数组按列优先存储，这意味着最左边（最里面）的索引是连续的。
从实际使用角度来看，这意味着数组切片<code>V(:,1)</code>是连续的，
而切片<code>V(1,:)</code>中的元素之间的间隔是数组列的大小。
当将数组片段传递给希望处理连续数据的过程时，这一点非常重要。</p>
<p>根据应用程序的不同，考虑内存的位置是很重要的，
通常在多维度上执行操作时，顺序访问总是应该以大小为1的长度增加。</p>
<p>在下面的例子中，计算两组点之间距离的倒数。</p>
<p>记这些点是连续存储在数组<code>xyz1</code>/<code>xyz2</code> 中，
而最内部的循环是矩阵<code>a</code>的最左边的索引增加。</p>
<pre><code class="language-fortran">subroutine coulomb_matrix(xyz1, xyz2, a)
  real(dp), intent(in) :: xyz1(:, :)
  real(dp), intent(in) :: xyz2(:, :)
  real(dp), intent(out) :: a(:, :)
  integer :: i, j
  do i = 1, size(a, 2)
    do j = 1, size(a, 1)
      a(j, i) = 1.0_dp/norm2(xyz1(:, j) - xyz2(:, i))
    end do
  end do
end subroutine coulomb_matrix
</code></pre>
<p>另一个例子是三维数组的第三维缩并，</p>
<pre><code class="language-fortran">do i = 1, size(amat, 3)
  do j = 1, size(amat, 2)
    do k = 1, size(amat, 1)
      cmat(k, j) = cmat(k, j) + amat(k, j, i) * bvec(i)
    end do
  end do
end do
</code></pre>
<p>可以在数组绑定中重映射，以使用连续数组切片。
允许将高维数组用作低维数组，而不需要重新格式化数组，
这样避免了有可能创建临时数组。</p>
<p>例如，可以使用矩阵向量操作来缩并三维数组的第三维:</p>
<pre><code class="language-fortran">subroutine matmul312(amat, bvec, cmat)
  real(dp), contiguous, intent(in), target :: amat(:, :, :)
  real(dp), intent(in) :: bvec(:)
  real(dp), contiguous, intent(out), target :: cmat(:, :)
  real(dp), pointer :: aptr(:, :)
  real(dp), pointer :: cptr(:)

  aptr(1:size(amat, 1)*size(amat, 2), 1:size(amat, 3)) =&gt; amat
  cptr(1:size(cmat)) =&gt; cmat

  cptr = matmul(aptr, bvec)
end subroutine matmul312
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="逐元操作"><a class="header" href="#逐元操作">逐元操作</a></h1>
<p>当使用子例程和函数时，有三种方法可以在数组上执行逐元操作:</p>
<ul>
<li><code>elemental</code> 过程；</li>
<li><em>显式形状</em> 数组；</li>
<li>实现向量的操作，并对不同的维度编写简单的包装器（内部使用<code>reshape</code>实现）。</li>
</ul>
<p>在第一种方法中，使用<code>elemental</code>关键字创建这样的函数:</p>
<pre><code class="language-fortran">real(dp) elemental function nroot(n, x) result(y)
  integer, intent(in) :: n
  real(dp), intent(in) :: x
  y = x**(1._dp / n)
end function nroot
</code></pre>
<p>所有参数（<code>in</code>和<code>out</code>）必须是标量。例如，您可以对任何（兼容的）形状的数组使用此函数，</p>
<pre><code class="language-fortran">print *, nroot(2, 9._dp)
print *, nroot(2, [1._dp, 4._dp, 9._dp, 10._dp])
print *, nroot(2, reshape([1._dp, 4._dp, 9._dp, 10._dp], [2, 2]))
print *, nroot([2, 3, 4, 5], [1._dp, 4._dp, 9._dp, 10._dp])
print *, nroot([2, 3, 4, 5], 4._dp)
</code></pre>
<p>输出如下，</p>
<pre><code class="language-fortran">3.0000000000000000
1.0000000000000000        2.0000000000000000        3.0000000000000000        3.1622776601683795
1.0000000000000000        2.0000000000000000        3.0000000000000000        3.1622776601683795
1.0000000000000000        1.5874010519681994        1.7320508075688772        1.5848931924611136
2.0000000000000000        1.5874010519681994        1.4142135623730951        1.3195079107728942
</code></pre>
<p>如上，通常情况下，<code>n</code>是一个参数，而<code>x</code>是一个任意形状的数组。
但是如您所见，只要最终的操作是有意义的（即如果一个参数是数组，
那么其他的参数必须是相同的形状的数组或标量），Fortran并不在乎其形式。
如果不满足，那么将得到一个编译错误。</p>
<p><code>elemental</code>关键字通常意味着<code>pure</code>关键字，因此过程必须是纯的，没有副作用。
您可以添加 <code>impure</code> 关键字来取消这一限制，</p>
<pre><code class="language-fortran">impure elemental subroutine write_all(a)
  inetger, intent(in) :: a
  write(*,&quot;(g0)&quot;) a
end subroutine write_all
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可分配数组"><a class="header" href="#可分配数组">可分配数组</a></h1>
<p><code>allocatable</code>属性为内存处理提供了安全的方式，
与具有<code>pointer</code>属性的变量相比，其内存是自动管理的，
一旦变量超出作用域，内存就会自动释放。 
使用<code>allocatable</code>变量可以消除在应用程序中产生内存泄漏的可能性。</p>
<p>可分配数组可以在子例程中用于创建临时或工作数组，
，而自动数组可能会由于所需空间太大不能放在栈中。</p>
<pre><code class="language-fortran">real(dp), allocatable :: temp(:)
allocate(temp(10))
</code></pre>
<p>分配状态可以使用<code>allocated</code>来检查，以避免未初始化的访问。</p>
<pre><code class="language-fortran">subroutine show_arr(arr)
  integer, allocatable, intent(in) :: arr(:)

  if (allocated(arr)) then
    print *, arr
  end if
end subroutine show_arr
</code></pre>
<p>要在一个过程中传递使用可分配变量，虚参必须带有<code>allocatable</code>属性。
如果与<code>intent(out)</code>结合使用，那么数组会在进入这个过程之前释放。</p>
<pre><code class="language-fortran">subroutine foo(lam)
  real(dp), allocatable, intent(out) :: lam(:)
  allocate(lam(5))
end subroutine foo
</code></pre>
<p>分配之后的数组可以像普通数组一样使用，</p>
<pre><code class="language-fortran">real(dp), allocatable :: lam(:)
call foo(lam)
</code></pre>
<p>已经分配的数组在没有事先释放的情况下不能再次进行分配。
同样，只能对已分配的数组进行释放。 重新分配数组使用如下操作，</p>
<pre><code class="language-fortran">if (allocated(lam)) deallocate(lam)
allocate(lam(10))
</code></pre>
<p>将已分配的数组传递给过程虚参不需要<code>allocatable</code>属性。</p>
<pre><code class="language-fortran">subroutine show_arr(arr)
  integer, intent(in) :: arr(:)

  print *, arr
end subroutine show_arr

subroutine proc
  integer :: i
  integer, allocatable :: arr(:)

  allocate(arr(5))

  do i = 1, size(arr)
    arr(i) = 2*i + 1
  end do
  call show_arr(arr)
end subroutine proc
</code></pre>
<p>在程序中传递未分配的数组将导致无效的内存访问。
可分配数组可以传递给带<code>optional</code>属性的虚参----如果它们未被分配，
则此参数实际上将不存在。
<code>allocatable</code>属性不仅限于数组，还可以与标量关联，
它可以与带<code>optional</code>属性的虚参结合使用。</p>
<p>使用<code>move_alloc</code>内部子程序，可以在带有<code>allocatable</code>属性的数组之间移动分配属性。</p>
<pre><code class="language-fortran">subroutine resize(var, n)
  real(wp), allocatable, intent(inout) :: var(:)
  integer, intent(in), optional :: n
  integer :: this_size, new_size
  integer, parameter :: inital_size = 16

  if (allocated(var)) then
    this_size = size(var, 1)
    call move_alloc(var, tmp)
  else
    this_size = initial_size
  end if

  if (present(n)) then
    new_size = n
  else
    new_size = this_size + this_size/2 + 1
  end if

  allocate(var(new_size))

  if (allocated(tmp)) then
    this_size = min(size(tmp, 1), size(var, 1))
    var(:this_size) = tmp(:this_size)
  end if
end subroutine resize
</code></pre>
<p>最后，分配不会不初始化数组的值。
未初始化数组的内容很可能只是之前在相应地址处的任何内容的字节。
分配时可以使用source进行初始化，</p>
<pre><code class="language-fortran">real(dp), allocatable :: arr(:)
allocate(arr(10), source=0.0_dp)
</code></pre>
<p><code>source</code>关键字支持标量，数组变量和常量。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文件io"><a class="header" href="#文件io">文件io</a></h1>
<p>在Fortran中，文件由<code>unit</code>单元标识符管理。
与文件系统的交互主要通过<code>open</code>和<code>inquire</code>内置过程进行。
通常，工作流是打开一个文件到一个单元标识符，读和（或）写，然后再关闭它。</p>
<pre><code class="language-fortran">integer :: io
open(newunit=io, file=&quot;log.txt&quot;)
! ...
close(io)
</code></pre>
<p>默认情况下，如果文件还不存在，并且为同时具有读和写操作的文件，
那么将会创建该文件。
写入现有文件将从第一个记录（即第一行）开始，因此默认情况下会覆盖文件。</p>
<p>要对文件的进行只读访问，必须指定<code>status</code>和<code>action</code>，</p>
<pre><code class="language-fortran">integer :: io
open(newunit=io, file=&quot;log.txt&quot;, status=&quot;old&quot;, action=&quot;read&quot;)
read(io, *) a, b
close(io)
</code></pre>
<p>如果文件不存在，则会发生运行时错误。
要在打开文件之前检查文件是否存在，可以使用 <code>inquire</code>函数。</p>
<pre><code class="language-fortran">logical :: exists
inquire(file=&quot;log.txt&quot;, exist=exists)
if (exists) then
  ! ...
end if
</code></pre>
<p>或者，使用<code>open</code>过程可以返回一个可选的<em>iostat</em>和<em>iomsg</em>:</p>
<pre><code class="language-fortran">integer :: io, stat
character(len=512) :: msg
open(newunit=io, file=&quot;log.txt&quot;, status=&quot;old&quot;, action=&quot;read&quot;, &amp;
  iostat=stat, iomsg=msg)
if (stat /= 0) then
  print *, trim(msg)
end if
</code></pre>
<p>注意，<em>iomsg</em>需要一个固定长度的字符变量，它应当有足够的长度来保存错误信息。</p>
<p>类似地，使用<em>status</em>和<em>action</em>关键字创建一个写入文件。
如下创建一个新的写入文件，</p>
<pre><code class="language-fortran">integer :: io
open(newunit=io, file=&quot;log.txt&quot;, status=&quot;new&quot;, action=&quot;write&quot;)
write(io, *) a, b
close(io)
</code></pre>
<p><code>status=&quot;replace&quot;</code>可以用于覆盖现有文件。
强烈建议在使用<em>status</em>之前，首先检查文件是否存在。</p>
<p>要追加到输出文件，可以显式指定<em>position</em>关键字，</p>
<pre><code class="language-fortran">integer :: io
open(newunit=io, file=&quot;log.txt&quot;, position=&quot;append&quot;, &amp;
  &amp; status=&quot;old&quot;, action=&quot;write&quot;)
write(io, *) size(v)
write(io, *) v(:)
close(io)
</code></pre>
<p>要重置文件中的位置，可以使用内置过程<code>rewind</code>和<code>backspace</code>。
<code>rewind</code>将重置为第一个记录（行），而<code>backspace</code>将返回到前一个记录（行）。</p>
<p>最后，要删除文件，文件必须要打开，并可以在关闭后删除。</p>
<pre><code class="language-fortran">logical :: exists
integer :: io, stat
inquire(file=&quot;log.txt&quot;, exist=exists)
if (exists) then
  open(file=&quot;log.txt&quot;, newunit=io, iostat=stat)
  if (stat == 0) close(io, status=&quot;delete&quot;, iostat=stat)
end if
</code></pre>
<p>一个有用的IO功能是暂存文件，它可以用<code>status=&quot;scratch&quot;</code>打开。 
关闭单元标识符后，它将自动删除。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="回调函数"><a class="header" href="#回调函数">回调函数</a></h1>
<p>回调函数是作为参数传递给另一个函数的函数。
创建此类回调函数的首选方法是提供<em>抽象接口</em>（abstract interface）声明回调函数的特征。
这样可以对传递的回调函数进行编译时检查。</p>
<pre><code class="language-fortran">module integrals
  use types, only: dp
  implicit none
  private
  public :: simpson, integrable_function

  abstract interface
    function integrable_function(x) result(func)
      import :: dp
      real(dp), intent(in) :: x
      real(dp) :: func
    end function integrable_function
  end interface

contains

  function simpson(f, a, b) result(s)
    real(dp), intent(in) :: a, b
    procedure(integrable_function) :: f
    real(dp) :: s

    s = (b-a) / 6 * (f(a) + 4*f((a+b)/2) + f(b))
  end function simpson

end module integrals
</code></pre>
<p>然后，通过导入模块，该函数将作为回调函数使用，如下例所示，</p>
<pre><code class="language-fortran">module demo_functions
  use types, only: dp
  implicit none
  private
  public :: test_integral

contains

  subroutine test_integral(a, k)
    real(dp), intent(in) :: a, k

    print *, simpson(f, 0._dp, pi)
    print *, simpson(f, 0._dp, 2*pi)
  contains

    function f(x) result(y)
      real(dp), intent(in) :: x
      real(dp) :: y
      y = a*sin(k*x)
    end function f
  end subroutine test_integral

end module demo_functions
</code></pre>
<p>如果导出抽象接口,可以创建具有正确特征的过程指针，
还可以进一步扩展回调函数，如下所示，</p>
<pre><code class="language-fortran">module demo_integrals
  use types, only: dp
  use integrals, only: simpson, integrable_function
  implicit none
  private
  public :: simpson2, integrable_function

contains

  function simpson2(f, a, b) result(s)
    real(dp), intent(in) :: a, b
    procedure(integrable_function) :: f
    real(dp) :: s
    real(dp) :: mid
    mid = (a + b)/2
    s = simpson(f, a, mid) + simpson(f, mid, b)
  end function simpson2

end module demo_integrals
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="回调函数中的类型转换"><a class="header" href="#回调函数中的类型转换">回调函数中的类型转换</a></h1>
<p>在回调函数的使用中，经常需要传递一些参数给被调用函数，例如<code>f(x)=a*sin(k*x)</code>，这时就需要类型转换。
类型转换基本上有五种不同的方法，每种方法都有自己的优缺点。</p>
<p>方法I、II和V可用于C和Fortran。方法III和方法IV只能在Fortran中使用。方法VI已过时，不应使用。</p>
<h2 id="工作数组"><a class="header" href="#工作数组">工作数组</a></h2>
<p>传递一个“工作数组”，该数组包含调用方所需的所有内容，并由被调用的例程解压缩。这是一种古老的方式--例如，LAPACK正是使用这种方法。</p>
<p>积分器:</p>
<pre><code class="language-fortran">module integrals
  use types, only: dp
  implicit none
  private
  public simpson

contains

real(dp) function simpson(f, a, b, data) result(s)
  real(dp), intent(in) :: a, b
  interface
    real(dp) function func(x, data)
    use types, only: dp
    implicit none
    real(dp), intent(in) :: x
    real(dp), intent(inout) :: data(:)
    end function
  end interface
  procedure(func) :: f
  real(dp), intent(inout) :: data(:)
  s = (b-a) / 6 * (f(a, data) + 4*f((a+b)/2, data) + f(b, data))
end function

end module
</code></pre>
<p>用法:</p>
<pre><code class="language-fortran">module test
  use types, only: dp
  use integrals, only: simpson
  implicit none
  private
  public foo

contains

real(dp) function f(x, data) result(y)
  real(dp), intent(in) :: x
  real(dp), intent(inout) :: data(:)
  real(dp) :: a, k
  a = data(1)
  k = data(2)
  y = a*sin(k*x)
end function

subroutine foo(a, k)
  real(dp) :: a, k
  real(dp) :: data(2)
  data(1) = a
  data(2) = k
  print *, simpson(f, 0._dp, pi, data)
  print *, simpson(f, 0._dp, 2*pi, data)
end subroutine

end module
</code></pre>
<h2 id="通用结构"><a class="header" href="#通用结构">通用结构</a></h2>
<p>定义一个通用的结构，包含目前实际的需求（甚至在未来的需求）。
这个通用结构类型可以根据未来的需求或设想而改变，但不太可能需要比如从传递实数更改为文本编辑器的实例化。</p>
<p>积分器:</p>
<pre><code class="language-fortran">module integrals
  use types, only: dp
  implicit none
  private
  public simpson, context

  type context
    ! This would be adjusted according to the problem to be solved.
    ! For example:
    real(dp) :: a, b, c, d
    integer :: i, j, k, l
    real(dp), pointer :: x(:), y(:)
    integer, pointer :: z(:)
  end type

contains

real(dp) function simpson(f, a, b, data) result(s)
  real(dp), intent(in) :: a, b
  interface
    real(dp) function func(x, data)
    use types, only: dp
    implicit none
    real(dp), intent(in) :: x
    type(context), intent(inout) :: data
    end function
  end interface
  procedure(func) :: f
  type(context), intent(inout) :: data
  s = (b-a) / 6 * (f(a, data) + 4*f((a+b)/2, data) + f(b, data))
end function

end module
</code></pre>
<p>用法:</p>
<pre><code class="language-fortran">module test
  use types, only: dp
  use integrals, only: simpson, context
  implicit none
  private
  public foo

contains

real(dp) function f(x, data) result(y)
  real(dp), intent(in) :: x
  type(context), intent(inout) :: data
  real(dp) :: a, k
  a = data%a
  k = data%b
  y = a*sin(k*x)
end function

subroutine foo(a, k)
  real(dp) :: a, k
  type(context) :: data
  data%a = a
  data%b = k
  print *, simpson(f, 0._dp, pi, data)
  print *, simpson(f, 0._dp, 2*pi, data)
end subroutine

end module
</code></pre>
<p>真正需要的灵活性只有这么多。例如，可以为此定义两种结构类型，一种用于情况A，另一种用于情况B。然后，每一个都将具有足够的通用性，并包含所有需要的部分和正确的标志。</p>
<p>注意：它不必是“一个包罗万象的抽象类”或空类。在“全部”和“无”之间有自然和可行的选择。</p>
<h2 id="私有的模块变量"><a class="header" href="#私有的模块变量">私有的模块变量</a></h2>
<p>通过传入模块变量来完全隐藏变量参数。</p>
<p>积分器:</p>
<pre><code class="language-fortran">module integrals
  use types, only: dp
  implicit none
  private
  public simpson

contains

real(dp) function simpson(f, a, b) result(s)
  real(dp), intent(in) :: a, b
  interface
    real(dp) function func(x)
    use types, only: dp
    implicit none
    real(dp), intent(in) :: x
    end function
  end interface
  procedure(func) :: f
  s = (b-a) / 6 * (f(a) + 4*f((a+b)/2) + f(b))
end function

end module
</code></pre>
<p>用法:</p>
<pre><code class="language-fortran">module test
  use types, only: dp
  use integrals, only: simpson
  implicit none
  private
  public foo

  real(dp) :: global_a, global_k

contains

real(dp) function f(x) result(y)
  real(dp), intent(in) :: x
  y = global_a*sin(global_k*x)
end function

subroutine foo(a, k)
  real(dp) :: a, k
  global_a = a
  global_k = k
  print *, simpson(f, 0._dp, pi)
  print *, simpson(f, 0._dp, 2*pi)
end subroutine

end module
</code></pre>
<p>但是，如果可能的话，最好避免这样的全局变量--即使实际上只是半全局变量(semi-global)。虽然有时这可能是最简单最干净的方式，然而，只要沿着II或IV的路线稍加思考，通常会有一个更好、更安全、更明确的方案。</p>
<h2 id="嵌套函数"><a class="header" href="#嵌套函数">嵌套函数</a></h2>
<p>积分器:</p>
<pre><code class="language-fortran">module integrals
  use types, only: dp
  implicit none
  private
  public simpson

contains

real(dp) function simpson(f, a, b) result(s)
  real(dp), intent(in) :: a, b
  interface
    real(dp) function func(x)
    use types, only: dp
    implicit none
    real(dp), intent(in) :: x
    end function
  end interface
  procedure(func) :: f
  s = (b-a) / 6 * (f(a) + 4*f((a+b)/2) + f(b))
end function

end module
</code></pre>
<p>用法:</p>
<pre><code class="language-fortran">subroutine foo(a, k)
use integrals, only: simpson
real(dp) :: a, k
print *, simpson(f, 0._dp, pi)
print *, simpson(f, 0._dp, 2*pi)

contains

real(dp) function f(x) result(y)
real(dp), intent(in) :: x
y = a*sin(k*x)
end function f

end subroutine foo
</code></pre>
<h2 id="使用typec_ptr指针"><a class="header" href="#使用typec_ptr指针">使用<code>type(c_ptr)</code>指针</a></h2>
<p>在C语言中，可以使用<code>void*</code>指针。在Fortran中，可以使用<code>type(c_ptr)</code>来达到完全相同的目的。</p>
<p>积分器:</p>
<pre><code class="language-fortran">module integrals
  use types, only: dp
  use iso_c_binding, only: c_ptr
  implicit none
  private
  public simpson

contains

real(dp) function simpson(f, a, b, data) result(s)
  real(dp), intent(in) :: a, b
  interface
    real(dp) function func(x, data)
    use types, only: dp
    implicit none
    real(dp), intent(in) :: x
    type(c_ptr), intent(in) :: data
    end function
  end interface
  procedure(func) :: f
  type(c_ptr), intent(in) :: data
  s = (b-a) / 6 * (f(a, data) + 4*f((a+b)/2, data) + f(b, data))
end function

end module
</code></pre>
<p>用法:</p>
<pre><code class="language-fortran">module test
  use types, only: dp
  use integrals, only: simpson
  use iso_c_binding, only: c_ptr, c_loc, c_f_pointer
  implicit none
  private
  public foo

  type f_data
    ! Only contains data that we need for our particular callback.
    real(dp) :: a, k
  end type

contains

real(dp) function f(x, data) result(y)
  real(dp), intent(in) :: x
  type(c_ptr), intent(in) :: data
  type(f_data), pointer :: d
  call c_f_pointer(data, d)
  y = d%a * sin(d%k * x)
end function

subroutine foo(a, k)
  real(dp) :: a, k
  type(f_data), target :: data
  data%a = a
  data%k = k
  print *, simpson(f, 0._dp, pi, c_loc(data))
  print *, simpson(f, 0._dp, 2*pi, c_loc(data))
end subroutine

end module
</code></pre>
<p>与以往一样，Fortran允许您在真正需要的情况下使用这种重新转换的优点，
但同时也有一些缺点，即编译和运行时检查可能无法捕获错误。因此，这将不可避免地会有更多的漏洞百出、容易出现bug的代码，所以需要考虑平衡成本和收益。</p>
<p>通常，在科学计算中，主要目的是表示和求解精确的数学公式（而不是创建一个包含无数按钮、下拉框和其他界面元素的GUI)，所以，最简单、最不容易出错、最快的选择是使用前面的方法之一。</p>
<h2 id="transfer内置函数"><a class="header" href="#transfer内置函数"><code>transfer</code>内置函数</a></h2>
<p>在Fortran 2003之前，做类型转换的唯一方法是使用<code>transfer</code>内置函数。</p>
<p>它在功能上与方法V等效，但更冗长，更容易出错。它现在已经过时了，应该使用方法V来代替。</p>
<p>Examples:</p>
<p><a href="http://jblevins.org/log/transfer">http://jblevins.org/log/transfer</a></p>
<p><a href="http://jblevins.org/research/generic-list.pdf">http://jblevins.org/research/generic-list.pdf</a></p>
<p><a href="http://www.macresearch.org/advanced_fortran_90_callbacks_with_the_transfer_function">http://www.macresearch.org/advanced_fortran_90_callbacks_with_the_transfer_function</a></p>
<h2 id="面向对象的策略"><a class="header" href="#面向对象的策略">面向对象的策略</a></h2>
<p>如下模块</p>
<pre><code class="language-fortran">module integrals

  use types, only: dp
  implicit none
  private

  public :: integrand, simpson

  ! User extends this type
  type, abstract :: integrand
  contains
    procedure(func), deferred :: eval
  end type

  abstract interface
    function func(this, x) result(fx)
      import :: integrand, dp
      class(integrand) :: this
      real(dp), intent(in) :: x
      real(dp) :: fx
    end function
  end interface

contains

real(dp) function simpson(f, a, b) result(s)
  class(integrand) :: f
  real(dp), intent(in) :: a, b
  s = ((b-a)/6) * (f%eval(a) + 4*f%eval((a+b)/2) + f%eval(b))
end function

end module
</code></pre>
<p>抽象类型准确地规定了集成例程需要什么，即函数求值的方法，但不会对用户强加任何其他东西。
用户扩展此类型，提供 eval 类型绑定过程的具体实现，并添加必要的上下文数据作为扩展类型的成员。</p>
<p>用法:</p>
<pre><code class="language-fortran">module example_usage

  use types, only: dp
  use integrals, only: integrand, simpson
  implicit none
  private

  public :: foo

  type, extends(integrand) :: my_integrand
    real(dp) :: a, k
  contains
    procedure :: eval =&gt; f
  end type

contains

function f(this, x) result(fx)
  class(my_integrand) :: this
  real(dp), intent(in) :: x
  real(dp) :: fx
  fx = this%a*sin(this%k*x)
end function

subroutine foo(a, k)
  real(dp) :: a, k
  type(my_integrand) :: my_f
  my_f%a = a
  my_f%k = k
  print *, simpson(my_f, 0.0_dp, 1.0_dp)
  print *, simpson(my_f, 0.0_dp, 2.0_dp)
end subroutine

end module
</code></pre>
<h2 id="关于-c的void-fortran-的两种实现方式-typec_ptr和transfer的完整示例"><a class="header" href="#关于-c的void-fortran-的两种实现方式-typec_ptr和transfer的完整示例">关于 C的<code>void *</code>，Fortran 的两种实现方式 <code>type(c_ptr)</code>和<code>transfer</code>的完整示例</a></h2>
<p>这里有三个等价代码：在C中使用<code>void*</code>，在Fortran中使用<code>type(c_ptr)</code>和<code>transfer()</code>：</p>
<table><thead><tr><th align="left"><strong>Language</strong></th><th align="left"><strong>Method</strong></th><th align="left"><strong>Link</strong></th></tr></thead><tbody>
<tr><td align="left">C</td><td align="left"><code>void *</code></td><td align="left"><a href="https://gist.github.com/1665641">https://gist.github.com/1665641</a></td></tr>
<tr><td align="left">Fortran</td><td align="left"><code>type(c_ptr)</code></td><td align="left"><a href="https://gist.github.com/1665626">https://gist.github.com/1665626</a></td></tr>
<tr><td align="left">Fortran</td><td align="left"><code>transfer()</code></td><td align="left"><a href="https://gist.github.com/1665630">https://gist.github.com/1665630</a></td></tr>
</tbody></table>
<p>C代码使用标准的C方法来编写接受回调和上下文的可扩展库。两个Fortran代码展示了如何做同样的事情。 <code>type(c_ptr)</code>方法与C版本等效，这是应该使用的方法。</p>
<p>这里的<code>transfer()</code>方法只是为了完善对比（在Fortran2003之前，这是唯一的方法），它有点麻烦，因为用户需要为每个类型创建辅助转换函数。因此，推荐使用<code>type(c_ptr)</code>方法代替它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fortran-程序中的陷阱"><a class="header" href="#fortran-程序中的陷阱">Fortran 程序中的陷阱</a></h1>
<p>翻译原文网址 https://www.cs.rpi.edu/~szymansk/OOF90/bugs.html</p>
<p>多年来，我们在Fortran 90中犯了很多有趣的错误，想和大家分享。欢迎您的贡献和经验，以便能够分享您的痛苦。
这些“陷阱”令人讨厌，因为它们在某些机器上不会失败，而在其他机器上可能会失败（考虑到编译器和机器平台的各种组合）。</p>
<h2 id="可选参数的陷阱"><a class="header" href="#可选参数的陷阱">可选参数的陷阱</a></h2>
<p>在本例中，用一个可选参数来确定是否打印标题。</p>
<pre><code class="language-Fortran">subroutine print_char(this,header)
    character(len=*), intent (in) :: this
    logical, optional, intent (in) :: header
    ! THIS IS THE WRONG WAY
    if (present(header) .and. header) then
        print *, 'This is the header '
    endif
    print *, this
end subroutine print_char

subroutine print_char2(this,header)
    character(len=*), intent (in) :: this
    logical, optional, intent (in) :: header
    ! THIS IS THE RIGHT WAY
    if (present(header)) then
        if (header) print *, 'This is the header '
    endif
    print *, this
end subroutine print_char2
</code></pre>
<p><strong>解释</strong></p>
<p>第一种方法不安全，因为编译器可以在计算<code>present</code>函数之前计算<code>header</code>参数。如果<code>header</code>参数实际上不存在，可能会发生越界内存引用(<code>Segmentation fault - invalid memory reference.</code>)。</p>
<h2 id="intentout的陷阱"><a class="header" href="#intentout的陷阱">Intent(out)的陷阱</a></h2>
<pre><code class="language-fortran">program intent_gotcha
    type mytype
        integer :: x
        real,allocatable:: y
    end type mytype
    type (mytype) :: a
    a%x = 1 ; a%y = 2.
    call assign(a)
    ! a%y COULD BE UNDEFINED HERE
    print *, a%x , a%y
contains

    subroutine assign(this)
        type (mytype), intent (out) :: this
        ! THIS IS THE WRONG WAY
        this%x = 2
    end subroutine assign

    subroutine assign2(this)
        type (mytype), intent (out) :: this
        ! THIS IS THE RIGHT WAY
        this%x = 2 ; this%y = 2.
    end subroutine assign2

    subroutine assign3(this)
        type (mytype), intent (inout) :: this
        ! THIS IS THE RIGHT WAY
        this%x = 2 
    end subroutine assign3
end program intent_gotcha
</code></pre>
<p><strong>解释</strong></p>
<p>问题是，当<code>intent(out)</code>与派生类型一起使用时，过程中未分配的任何成员都可能在退出时变得未定义。例如，即使在进入该例程时定义了<code>%y</code>，但在退出时它可能会变得未定义，因为它从未在例程中分配过。教训是，当使用<code>intent(out)</code>时，派生类型的所有成员都应该在一个过程中指定。<code>Intent(out)</code>的行为类似于函数中的结果变量：必须分配所有成员。
或者，<strong>使用</strong><code>intent(inout)</code>。</p>
<h2 id="初始化局部变量的陷阱"><a class="header" href="#初始化局部变量的陷阱">初始化局部变量的陷阱</a></h2>
<pre><code class="language-fortran">real function kinetic_energy(v)
    real, dimension(:), intent(in) :: v
    integer i
    ! THIS IS THE WRONG WAY
    real :: ke = 0.0
    do i = 1, size(v)
        ke = ke + v(i)**2
    enddo
    kinetic_energy = .5*ke
end function kinetic_energy

real function kinetic_energy2(v)
    real, dimension(:), intent(in) :: v
    integer i
    ! THIS IS THE RIGHT WAY
    real :: ke
    ke = 0.
    do i = 1, size(v)
        ke = ke + v(i)**2
    enddo
    kinetic_energy2 = .5*ke
end function kinetic_energy2
</code></pre>
<p><strong>解释</strong></p>
<p>声明时初始化的局部变量具有隐式<code>save</code>属性。<code>ke</code>仅在<strong>第一次</strong>调用函数时初始化。在后续调用中，保留旧的<code>ke</code>值。
为了避免混淆，最好将<code>save</code>属性显式地添加到这些本地初始化的变量中，即使看起来是多余的。</p>
<h2 id="调用fortran-90-风格的子程序"><a class="header" href="#调用fortran-90-风格的子程序">调用Fortran 90 风格的子程序</a></h2>
<pre><code class="language-fortran">program main
    real, dimension(5) :: x

    x = 0.
    ! THIS IS WRONG
    call incb(x)
    print *, x

end program main

subroutine incb(a)
    ! this is a fortran90 style subroutine
    real, dimension(:) :: a
    a = a + 1.
end subroutine incb
</code></pre>
<p><strong>解释</strong></p>
<p>子例程<code>incb</code>使用<code>Fortran 90</code>中的假定形状数组(包含维度(:))。此类例程必须位于模块<code>module</code>中，或者在使用它们的任何地方都有一个显式接口。</p>
<p>调用此类过程的一个正确方法是使用显式接口，如下所示：</p>
<pre><code class="language-fortran">program main
    real, dimension(5) :: x

    ! THIS IS THE RIGHT WAY
    interface
        subroutine incb(a)
        real, dimension(:) :: a
        end subroutine incb
    end interface

    x = 0.
    call incb(x)
    print *, x

end program main

subroutine incb(a)
    ! this is a fortran90 style subroutine
    real, dimension(:) :: a
    a = a + 1.
end subroutine incb
</code></pre>
<p>如果例程位于模块中，则会自动生成接口，无需显式编写。</p>
<pre><code class="language-fortran">! THIS IS ANOTHER RIGHT WAY
module inc
contains
    subroutine incb(a)
        ! this is a fortran90 style subroutine
        real, dimension(:) :: a
        a = a + 1.
    end subroutine incb
end module inc

program main
    use inc
    real, dimension(5) :: x

    x = 0.
    call incb(x)
    print *, x

end program main
</code></pre>
<p>如果使用接口，接口必须与实际的函数匹配。</p>
<h2 id="fortran77-风格的接口"><a class="header" href="#fortran77-风格的接口">Fortran77 风格的接口</a></h2>
<pre><code class="language-fortran">      program main
      real, dimension(5) :: x

! interface to Fortran 77 style routine
      interface
         subroutine inca(a,n)
         integer :: n
! THIS IS THE WRONG WAY
         real, dimension(:) :: a
! THIS IS THE RIGHT WAY
         real, dimension(n) :: a
         end subroutine inca
      end interface

      x = 0.
      call inca(x,5)
      print *, x

      end program main

      subroutine inca(a,n)
! this is a fortran77 style subroutine
      dimension a(n)
      do 10 j = 1, n
      a(j) = a(j) + 1.
   10 continue
      return
      end
</code></pre>
<p><strong>解释</strong></p>
<p>接口声明必须始终与实际的子例程声明相匹配。在本例中，接口语句引用Fortran 90样式的假定形状数组。实际的子例程引用Fortran 77显式形状数组。这里的教训是：Fortran 77风格例程的接口必须只使用Fortran 77风格的构造。
在本例中，允许完全省略接口，因为没有接口的例程在默认情况下被视为Fortran77样式的例程。但是，如果忽略了接口，编译器将<strong>不再检查调用过程的参数是否与接口中列出的参数一致</strong>。</p>
<h2 id="函数重载"><a class="header" href="#函数重载">函数重载</a></h2>
<p>Fortran 90允许对不同的函数使用相同的函数名，只要函数的参数不同。人们会认为下面的函数<code>first_sub</code>和<code>second_sub</code>是不同的，因为在<code>first_sub</code>中，第一个参数是实数，第二个参数是整数，而在<code>second_sub</code>中，参数是相反的。实际上并不是这样。</p>
<pre><code class="language-fortran">interface first_or_second
    module procedure first_sub, second_sub
end interface

subroutine first_sub(a,i)
    real :: a
    integer :: i
    ...
end subroutine first_sub
!
subroutine second_sub(i,a)
    integer :: i
    real :: a
    ...
end subroutine second_sub
</code></pre>
<p><strong>解释</strong></p>
<p>原因是Fortran 90允许按名称（关键字）参数调用过程。</p>
<pre><code class="language-fortran">real :: b
integer :: n
call first_or_second(i=n,a=b)
</code></pre>
<p>该方法将不起作用，因为当按关键字调用时，<code>first_sub</code>和<code>second_sub</code>无法区分，</p>
<pre><code class="language-fortran">call first_sub(i=n,a=b)
call second_sub(i=n,a=b)
</code></pre>
<p>因此不能定义通用函数。通用函数必须能够按类型和名称区分其参数。
解决方案是不要在两个过程中使用相同的虚参名称。例如，以下方法可行：</p>
<pre><code class="language-fortran">subroutine second_sub(i,aa)
    integer :: i
    real :: aa
    ...
end subroutine second_sub
</code></pre>
<h2 id="可分配数组自动分配"><a class="header" href="#可分配数组自动分配">可分配数组自动分配</a></h2>
<p>Fortran 2003之后的标准允许对可分配数组自动分配，这个特性可能为开发者带来方便，同时也带来一些隐藏的bug</p>
<pre><code class="language-fortran">program alloc
    implicit none
    integer,allocatable::a(:)
    integer::b(4)
    a=[1,2]
    write(*,*)size(a)
    a=[a,3]
    write(*,*)size(a)
    a=b+1
    write(*,*)size(a)
end program alloc

</code></pre>
<p><strong>解释</strong></p>
<pre><code class="language-fortran">    a=[1,2]! 1,此时a数组自动分配，大小为2
    a=[a,3]! 2,此时数组自动追加元素，大小为3
    a=b+1  ! 3,此时由于b+1得到一个大小为4的数组，a会被重新分配，所以大小为4
</code></pre>
<p>在计算中，第3种情况可能带来一些无法错误，可以利用如下的办法解决</p>
<pre><code class="language-fortran">    a(:)=b+1 
</code></pre>
<p>此时，编译器会检查数组两边大小是否匹配，然后抛出错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在windows系统下进行fortran编程"><a class="header" href="#在windows系统下进行fortran编程">在Windows系统下进行Fortran编程</a></h1>
<p>该篇章将着重讲述我们在Windows下编程进行Fortran编程。</p>
<h2 id="gfortran篇"><a class="header" href="#gfortran篇">GFortran篇</a></h2>
<p>在Windows系统下，我们推荐MSYS2-GFortran，原因是MSYS2基于pacman包管理滚动更新，拥有丰富的开发工具集且使用简单，这往往适用于极客、爱好者。<br>
如果你对编程环境的稳定性需求很高，你可以前往<a href="http://www.equation.com/">equation.com</a>或者<a href="https://winlibs.com/">winlibs.com</a>（一些国外网站可能无法访问）下载固定版本号的Mingw-w64-GCC编程套件，
或者使用<a href="https://software.intel.com/content/www/us/en/develop/tools/oneapi/all-toolkits.html">Intel OneAPI</a>套件。<br>
如果你对原生编程工具集有需求，或者Mingw环境出现了BUG，你可以试着安装<a href="https://docs.microsoft.com/zh-cn/windows/wsl/setup/environment">WSL2</a>。</p>
<h2 id="intel-oneapi篇"><a class="header" href="#intel-oneapi篇">Intel OneAPI篇</a></h2>
<p>Intel出品的OneAPI套件，性能强劲，且已经被免费提供了。适合对高性能、稳定性有需求的用户。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="环境路径"><a class="header" href="#环境路径">环境路径</a></h1>
<p>在Windows下进行编程，往往离不开环境路径，它使得可执行程序可以被索引。<br>
通过在键盘上按下<code>Win</code>键，再输入<code>path</code>可以快速启动“编辑系统环境变量”。</p>
<p><img src="Fortran-Programming-in-Windows/images/Path.png" alt="环境变量" /></p>
<h2 id="用户变量和系统变量"><a class="header" href="#用户变量和系统变量">用户变量和系统变量</a></h2>
<p>一台计算机可以创建多个用户账户。<br>
用户变量框内设置的环境变量只适用于计算机的当前账号；系统变量框内设置的环境变量将适用于该计算机的所有用户账号。</p>
<h2 id="三类环境变量"><a class="header" href="#三类环境变量">三类环境变量</a></h2>
<p>需要注意的是环境变量根据用途，主要可以分为三类：</p>
<ol>
<li><code>Path</code>：存储可执行程序的路径；</li>
<li><code>OS</code>：值一般为<code>Windows_NT</code>，用以程序判断当前系统类型；</li>
<li>其他环境变量。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用gfortran"><a class="header" href="#使用gfortran">使用GFortran</a></h1>
<p>微软公司开发的Windows系统具有强大的图形用户界面🎨，是我们常用的操作系统。<br>
GCC Fortran编译器，对Fortran新标准的支持非常及时，是一款免费🍻的开源软件。</p>
<blockquote>
<p>🔰 提示：以下教程，同样适用于在<strong>Visual Studio Code</strong>中使用Intel OneAPI（需要做出适应性改变：gfortran改为ifort）。安装OneAPI请参考<a href="Fortran-Programming-in-Windows/use-OneAPI-in-Windows.html#%E5%AE%89%E8%A3%85oneapi%E7%9A%84%E7%8B%AC%E7%AB%8B%E7%BB%84%E4%BB%B6%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%A1%88">安装OneAPI的独立组件（第二种方案）</a>。</p>
</blockquote>
<h2 id="使用msys2-gfortran"><a class="header" href="#使用msys2-gfortran">使用MSYS2-GFortran</a></h2>
<p>可以将MSYS2简单地理解为一个包管理器，集成了<code>pacman</code>和<a href="https://sourceforge.net/projects/mingw/"><code>Mingw-w64</code></a>。</p>
<h3 id="安装msys2软件"><a class="header" href="#安装msys2软件">安装MSYS2软件</a></h3>
<p>前往<a href="https://www.msys2.org/">MSYS2项目官方网站</a>📡，点击图示箭头指向的链接，下载MSYS2软件，阅读网页提供的<a href="https://www.msys2.org/wiki/Home/">安装教程进行安装和使用</a>📜。</p>
<img src="Fortran-Programming-in-Windows/images/MSYS2-Main-Page.png" alt="MSYS2主页截图" style="zoom:50%;" />
<p>当我们在使用MSYS2软件的过程中遇到困难或者软件漏洞时，我们可以向<a href="https://github.com/msys2/msys2.github.io/issues">MSYS2项目的GitHub仓库的议题</a>🎯寻求帮助。</p>
<h3 id="安装msys2-gfortran软件"><a class="header" href="#安装msys2-gfortran软件">安装MSYS2-GFortran软件</a></h3>
<p>首先，我们熟悉一下MSYS2软件的命令行基础操作🕹，这在MSYS2项目官方提供的文档中能找到：</p>
<pre><code class="language-sh">pacman -Syu                  # 升级msys2内部组件和仓库信息
pacman -Ss &lt;package_name&gt;    # 搜索软件
pacman -S  &lt;package_name&gt;    # 安装软件
pacman -Qs &lt;package_name&gt;    # 查询本地安装的特定软件
pacman -Rs &lt;package_name&gt;    # 卸载软件
pacman -R --help             # 查询命令的帮助文档
...
</code></pre>
<p>请务必灵活🏓使用MSYS2软件，该软件在运行前有一些个性化的配置文件可以设置，当然保持默认也是不错的。<br>现在我们知道，可以通过下面的方式在MSYS2软件中安装GFortran：</p>
<pre><code class="language-sh">pacman -Ss fortran           # 查询名字中含“Fortran”字符的包
pacman -S  ucrt64/mingw-w64-ucrt-x86_64-gcc-fortran    # 安装ucrt64版本的gfortran
</code></pre>
<p>当然，我们还可以使用MSYS2软件，下载<code>GNU Make/CMake/openBLAS/Python/Golang/...</code>等丰富的软件或者链接库。GCC WIKI为我们提供了<a href="https://gcc.gnu.org/wiki/GFortran">一些GFortran的信息文档</a>，其中就有<a href="https://gcc.gnu.org/onlinedocs/gfortran.pdf">GFortran最新的帮助文档</a>。</p>
<pre><code class="language-sh">gfortran &lt;name&gt;.f90          # 编译fortran源代码文件
gfortran --help              # 查询gfortran命令行参数的帮助文档
...
</code></pre>
<p>如果我们没有更改MSYS2软件的安装路径，则安装的GFortran软件应该是在<code>C:\msys64</code>路径下的特定环境的子文件下，我们最好将它引入到Windows软件的的环境路径🔗中，以方便我们使用它（gfortran.exe）。例如路径，</p>
<pre><code class="language-sh">C:/msys64/ucrt64/bin         # 二进制的可执行程序所在路径
C:/msys64/ucrt64/lib         # 可执行程序的动态链接库依赖所在路径
</code></pre>
<blockquote>
<p>🔰 提示：这里默认我们现在大多数使用的硬件是64位的，且使用较新的MSYS2环境（UCRT），有个性化需求可以进行自定义。</p>
</blockquote>
<h2 id="使用visul-studio-code编辑器进行编码"><a class="header" href="#使用visul-studio-code编辑器进行编码">使用Visul Studio Code编辑器进行编码</a></h2>
<p><a href="https://code.visualstudio.com/">Visual Studio Code（简称，VS Code或code）</a>是一款由微软公司主导的免费开源、逐渐强大的代码编辑器软件。<br>
初次使用VS Code编辑器，可以尝试阅读<a href="https://code.visualstudio.com/docs">VS Code帮助文档</a>。</p>
<h3 id="推荐的vs-code插件"><a class="header" href="#推荐的vs-code插件">推荐的VS Code插件</a></h3>
<p>针对Fortran编程，我们有一些可以方便特定编程需求的插件🛠，被列出来仅供参考：</p>
<pre><code class="language-markdown">+ 中文软件包插件
+ Modern Fortran
+ Fortran IntelliSense
+ GDB Debugger - Beyond
+ Copilot (可选)
+ VSCode Great Icons (可选)
+ Better TOML (可选)
</code></pre>
<h3 id="推荐的编程样式"><a class="header" href="#推荐的编程样式">推荐的编程样式</a></h3>
<p>为了提高代码的可读性💡，可以使用以下的单元编程样式：</p>
<pre><code class="language-fortran">!&gt; 相加
subroutine add(x, y, z)
    
    real, intent(in)  :: x, y
    real, intent(out) :: z     !! 返回值
    
    !&gt; 加法
    z = x + y
    
end subroutine add
</code></pre>
<p>在区块代码前使用<code>!&gt;</code>注释标头使得VS Code的Fortran插件能解析注释；在单行注释时，有品位地使用<code>!&gt;</code>或<code>!!</code>可以提高代码的可读性。</p>
<blockquote>
<p><code>!&gt;</code>注释标头被<a href="https://github.com/fortran-lang">Fortran-Lang组织</a>与<a href="https://fortran-lang.discourse.group/">社区</a>广泛使用。</p>
</blockquote>
<h3 id="使用fpm构建fortran代码"><a class="header" href="#使用fpm构建fortran代码">使用FPM构建Fortran代码</a></h3>
<p><a href="https://github.com/fortran-lang/fpm">Fortran Package Manager（FPM）</a>是Fortran-Lang组织主导、为Fortran语言专门定制开发的免费、开源的包管理器和构建系统。</p>
<blockquote>
<p>🔰 提示：fortran-lang/fpm不仅支持GFortran，还支持OneAPI和<a href="https://lfortran.org/">LFortran</a>等其他Fortran编译器。</p>
</blockquote>
<p>我们现在可以使用MSYS2软件来安装FPM，也可以前往<a href="https://github.com/fortran-lang/fpm">Fortran Package Manager (fpm) (github.com)</a>仓库手动编译出可执行程序FPM，届时务必阅读仓库提供的帮助文档<a href="https://github.com/fortran-lang/fpm#readme"><code>README.md</code></a>。别忘了将手动编译的FPM引入Windows软件的的环境路径🔗中，以方便我们使用它（fpm.exe）。</p>
<pre><code class="language-sh">pacman -Ss fpm              # 查询名字中含“fpm”字符的包
pacman -S ucrt64/mingw-w64-ucrt-x86_64-fpm  # 安装fpm软件
</code></pre>
<p><strong>我们来演示一个FPM项目的初始化、编写、构建、运行：</strong></p>
<p>我们可以搭配命令行工具（pwsh、bash）使用FPM，也可以在VS Code打开hello_world文件夹，<strong>此后我们就可以专心编写代码了</strong>💻。</p>
<pre><code class="language-sh">fpm new hello_world &amp;&amp; cd hello_world       # 新建FPM项目并切换到文件夹下: hello_world
fpm build                   # 编译FPM项目
fpm run                     # 运行主程序🚀
fpm test --help             # 获取特定命令行参数的帮助文档
code .                      # 使用VS Code打开当前文件夹
...
</code></pre>
<img src="Fortran-Programming-in-Windows/images/hello_world-in-code.png" alt="使用VS Code编辑hello_world项目" style="zoom:75%;" />
<blockquote>
<p>🔰 提示：<code>fpm build</code>类似Visual Studio的Debug模式，<code>fpm build --profile release</code>类似Visual Studio的Release模式。</p>
</blockquote>
<p>作为用户，我们可以阅读🔍<a href="https://fpm.fortran-lang.org/zh_CN/index.html">fpm的用户中文帮助文档</a>；如果我们想成为FPM的贡献者和开发者，阅读<a href="https://fpm.fortran-lang.org/index.html#fortran-package-manager-developer-documentation">FPM开发者文档</a>将是有帮助的。</p>
<h3 id="使用cmake构建代码可选"><a class="header" href="#使用cmake构建代码可选">使用CMake构建代码（可选）</a></h3>
<p>CMake是一款免费、开源、优秀的代码构建系统，它的跨平台能力很强、支持多编译器，功能强大同时也具有一定难度。<br>
我们可以前往<a href="https://cmake.org/">CMake官方网站</a>阅读<a href="https://cmake.org/documentation/">帮助文档</a>。</p>
<pre><code class="language-sh">pacman -Ss cmake            # 查询名字中含“cmake”字符的包
pacman -S  ucrt64/mingw-w64-ucrt-x86_64-cmake   # 安装CMake软件
cmake  --help               # 获取cmake命令行参数的帮助文档
</code></pre>
<h4 id="单个源文件代码"><a class="header" href="#单个源文件代码">单个源文件代码</a></h4>
<p>CMake使用配置文件来构建我们的代码，如<code>CMakelists.txt</code>。假设我们想构建一个“Hello Fortran”代码，在<code>hello_fortran.f90</code>同一文件夹下，我们创建一个<code>CMakelists.txt</code>：</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.0)                     # 设置要使用CMake的最小版本，此处取为3.0

project(fortran_basics LANGUAGES Fortran)               # 设置工程的名字为fortran_basics，和编译工程的编程语言为Fortran

set(CMAKE_Fortran_MODULE_DIRECTORY
    ${CMAKE_BINARY_DIR}/modules)
file(MAKE_DIRECTORY ${CMAKE_Fortran_MODULE_DIRECTORY})  # 设置编译器编译代码生成的*.mod文件被储存在目标构建文件夹下

add_compile_options(-Wall -Wextra)                      # 设置额外的编译器选项（命令行参数），此处为`-Wall -Wextra`

add_executable(hello_fortran.exe hello_fortran.f90)     # 设置具体的编译内容，此处设置将hello_fortran.f90编译成hello_fortran.exe
</code></pre>
<p>当我们编译代码时，CMake会生成很多具体的配置文件，可以将它们生成在一个叫做<code>build</code>的文件夹下，以保持整齐的文件夹内容。</p>
<pre><code class="language-sh">mkdir build &amp;&amp; cd build     # 新建一个文件夹`build`，并切换到该文件夹
cmake -G &quot;MSYS Makefiles&quot; ..    # CMake根据命令行参数`-G &quot;MSYS Makefiles&quot; ..`和CMakelists.txt的信息生成makefiles
make                        # 现在我们可以使用make来编译代码了
./hello_fortran.exe         # 编译成功，我们可以运行代码了
</code></pre>
<img src="Fortran-Programming-in-Windows/images/CMake-hello_fortran.png" alt="在VS Code中使用CMake" style="zoom:75%;" />
<h4 id="多个源代码文件"><a class="header" href="#多个源代码文件">多个源代码文件</a></h4>
<pre><code class="language-cmake">add_executable(hello_fortran.exe 
    hello_fortran.f90
    print_stars.f90)  # 我们需要更新CMakelists.txt中具体的编译内容，增加print_stars.f90编译到hello_fortran.exe
</code></pre>
<img src="Fortran-Programming-in-Windows/images/CMake-hello_fortran2.png" alt="在VS Code中使用CMake" style="zoom:75%;" />
<h2 id="使用vs-code进行代码调试"><a class="header" href="#使用vs-code进行代码调试">使用VS Code进行代码调试</a></h2>
<p>调试的方法主要有两种，一种是<code>write</code>到屏幕或文件中，另一种是使用GDB类的软件来调试。</p>
<h3 id="使用gdb来调试代码"><a class="header" href="#使用gdb来调试代码">使用GDB来调试代码</a></h3>
<p>GDB是GNU开源的Debug免费软件，可以前往<a href="https://www.gnu.org/software/gdb/">GDB官网</a>
下载<a href="https://sourceware.org/gdb/download/onlinedocs/gdb.pdf">帮助文档</a>。</p>
<pre><code class="language-sh">pacman -Ss gdb              # 查询名字中含“gdb”字符的包
pacman -S  ucrt64/mingw-w64-ucrt-x86_64-gdb     # 安装gdb软件
gdb  --help                 # 获取gdb命令行参数的帮助文档
</code></pre>
<p>使用GDB软件的命令行模式更强大，但也对使用者的要求也更高。<br>
在VS Code中我们可以通过安装<code>GDB Debugger - Beyond</code>插件扩展来运行<strong>图形化的GDB调试流程</strong>。</p>
<p><img src="https://dev.azure.com/coolchyni/00de68fc-20fd-4cff-8681-a0a0be966def/_apis/git/repositories/ce435a7c-1ae2-41d1-b97d-5c3f504c4c92/items?path=%2fbeyond-debug.gif&amp;versionDescriptor%5bversionOptions%5d=0&amp;versionDescriptor%5bversionType%5d=0&amp;versionDescriptor%5bversion%5d=master&amp;resolveLfs=true&amp;format=octetStream&amp;api-version=5.0" alt="GDB" /></p>
<p>你需要做的是先完整地阅读<a href="https://marketplace.visualstudio.com/items?itemName=coolchyni.beyond-debug">它的概述📌</a>（上面动图来自该概述链接），
然后在<code>GDB Debugger - Beyond</code>插件生成的<code>.vscode/launch.json</code>文件中设置好输出<code>-g</code>后的可执行程序<code>*.exe</code>，设置好断点，启动调试模式！</p>
<pre><code class="language-json">{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;type&quot;: &quot;by-gdb&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;name&quot;: &quot;Launch(gdb)&quot;,
            &quot;program&quot;: &quot;./a.exe&quot;,  // 设置好输出`-g`的含调试信息的可执行程序，最好使用相对路径，简单易用。
            &quot;cwd&quot;: &quot;${workspaceRoot}&quot;
        }
    ]
}
</code></pre>
<p>为了方便我们查找代码BUG，GFortran提供了一些非常有用的编译选项，可以进行编译时和运行时的示警和报错。<br></p>
<pre><code class="language-sh"># -fcheck=bounds: 数组越界检查
# -std=f2008: 强制使用Fortran2008的语法规范，保证程序跨编译器，跨平台
# -Wall: 检查一些常见的Warning，例如变量未使用，变量未初始化等等
# ... ...
gfortran -g -fcheck=bounds -std=f2008 -Wall hello_world.f90
</code></pre>
<p>我们推荐使用FPM软件来构建代码，FPM默认会启用一些编译选项。例如，</p>
<pre><code>-Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fcheck=bounds -fcoarray=single
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用oneapi套件"><a class="header" href="#使用oneapi套件">使用OneAPI套件</a></h1>
<p><a href="https://software.intel.com/content/www/us/en/develop/tools/oneapi/all-toolkits.html">Intel OneAPI</a>为我们免费提供了两个版本的Fortran编译器，一个是经典的<code>ifort</code>，另一个是基于LLVM后端的<code>ifx</code>（尚处于beta版本），且拥有强大的MKL数学库，配套完善的开发测试组件，还有<a href="https://software.intel.com/content/www/us/en/develop/documentation/get-started-with-fortran-compiler/top/get-started-on-windows.html">丰富的帮助文档</a>📔。</p>
<h2 id="安装visual-studio的注意事项"><a class="header" href="#安装visual-studio的注意事项">安装Visual Studio的注意事项</a></h2>
<p>Windows下的Intel OneAPI往往是搭配最新版Visual Studio（简称，VS）使用，VS社区版是免费提供的。<br>
如果担心以后参加工作，VS企业版需要付费使用，你可以尝试在VS Code中使用<a href="Fortran-Programming-in-Windows/use-OneAPI-in-Windows.html#%E5%9C%A8vs-code%E4%B8%AD%E4%BD%BF%E7%94%A8oneapi%E5%A5%97%E4%BB%B6">OneAPI</a>或者<a href="Fortran-Programming-in-Windows/use-GFortran-in-Windows.html">GFortran</a>🍻。</p>
<blockquote>
<p>🔰 提示：实际上，VS搭配OneAPI是一对经典组合，稳定强劲。但我们仍推荐用户对Linux式（命令行式）编程有所浅尝，否则VS会极大地禁锢你的编程思维。</p>
</blockquote>
<p>Windows下使用OneAPI，不一定必须要与VS搭配，Intel官方正在组织开发VS Code的OneAPI插件（尚不成熟），且<a href="https://github.com/fortran-lang/fpm">fortran-lang/fpm</a>也支持OneAPI编译器，但对于新手和追求稳定性的用户还是推荐使用VS。</p>
<p>安装VS，要注意勾选以下4个组件⚙：
<img src="Fortran-Programming-in-Windows/images/Visual-Studio.png" alt="注意事项" /></p>
<h2 id="安装base-toolkit和hpc-toolkit"><a class="header" href="#安装base-toolkit和hpc-toolkit">安装<code>Base Toolkit</code>和<code>HPC Toolkit</code></a></h2>
<p>对于新手用户，非常保守和默认的做法是安装<code>OneAPI Base Toolkit</code>和<code>OneAPI HPC Toolkit</code>，安装的时候稍微注意一下，是否在OneAPI安装过程中、与VS集成时出现惊叹号，这可能是因为你未完全安装以上图示4个VS组件：</p>
<ol>
<li>安装<a href="https://visualstudio.microsoft.com/zh-hans/">最新版Visual Studio</a>；</li>
<li>安装<a href="https://software.intel.com/content/www/us/en/develop/tools/oneapi/all-toolkits.html#base-kit"><code>Base Toolkit</code></a>（3.71GB）；</li>
<li>安装<a href="https://software.intel.com/content/www/us/en/develop/tools/oneapi/all-toolkits.html#hpc-kit"><code>HPC Toolkit</code></a>（1.23GB）。</li>
</ol>
<p>此后我们就<strong>可以开始专心编程、实现业务了</strong>。<br></p>
<blockquote>
<p>🔰 提示：<br></p>
<ol>
<li>快捷键<code>CTRL F5</code>是开始运行（不调试），<code>F5</code>是开始调试。<br></li>
<li>进入菜单<code>工具&gt;选项&gt;文本编辑器&gt;Fortran&gt;Advanced</code>启用一些有用的Fortran IDE功能。<br></li>
<li>记得了解一点动态、静态链接库的概念。</li>
</ol>
</blockquote>
<h2 id="安装oneapi的独立组件第二种方案"><a class="header" href="#安装oneapi的独立组件第二种方案">安装OneAPI的独立组件（第二种方案）</a></h2>
<p>通过安装<code>Base Toolkit</code>和<code>HPC Toolkit</code>，细心的话能发现，其中OneAPI套件包含了很多我们Fortran编程用不到的一些组件，占用了我们较多的电脑存储。<br>
且我们发现用户安装OneAPI的<code>Base Toolkit</code>和<code>HPC Toolkit</code>，会导致编程概念的模糊🧿：编码时，编译时，运行时，链接库等概念。<br>
所以我们引出<strong>第二种安装OneAPI的方式，组件化、轻量化安装</strong>，这往往适合极客、爱好者和家庭作业需求的学生。（如果你有很强的C-Fortran交互编程需求，推荐安全完整套件，此时安装独立组件的意义不大）</p>
<p>前往OneAPI的网页（<a href="https://software.intel.com/content/www/us/en/develop/articles/oneapi-standalone-components.html">Single Component Downloads and Runtime Versions</a>）进行下载你所需要的组件，以OneAPI 2021.4发行版为例，我们推荐以下组件：</p>
<ol>
<li><a href="https://registrationcenter-download.intel.com/akdlm/irc_nas/18215/w_ifort_runtime_p_2021.4.0.3556.exe">OneAPI Fortran运行时</a>（30.6MB）；</li>
<li><a href="https://registrationcenter-download.intel.com/akdlm/irc_nas/18215/w_fortran-compiler_p_2021.4.0.3208_offline.exe">OneAPI Fortran编译器</a>（603.65MB）；</li>
<li><a href="https://registrationcenter-download.intel.com/akdlm/irc_nas/18230/w_onemkl_p_2021.4.0.640_offline.exe">OneAPI MKL数学库</a>（1.22GB）（可选）。</li>
</ol>
<blockquote>
<p>🔰 提示：OneAPI中有Intel实现的Python解释器，它的性能比Python官方提供的编译器更强，如果有Python编程的需要，可以试一试。</p>
</blockquote>
<h2 id="在vs-code中使用oneapi套件"><a class="header" href="#在vs-code中使用oneapi套件">在VS Code中使用OneAPI套件</a></h2>
<p>Visual Studio中使用OneAPI很方便也简单，此处暂不介绍，现在介绍VS Code中使用OneAPI的可行方式，<strong>我们依然想将OneAPI在Windows下编程从Visual Studio中
拉出来，加入fpm的生态进程中来。</strong></p>
<blockquote>
<p>🔰 Intel 已经为 VS Code 开发了相关插件 <a href="https://marketplace.visualstudio.com/items?itemName=intel-corporation.oneapi-environment-configurator">Environment Configurator for Intel(R) oneAPI Toolkits</a>，与下文原理类似，但其会一定程度拖慢 VS Code 的启动时间，相信之后能得到改善。</p>
</blockquote>
<h3 id="基本原理"><a class="header" href="#基本原理">基本原理</a></h3>
<p>OneAPI的运行环境依赖项较多，手动为它们添加环境路径几乎不现实，我们解析OneAPI在开始菜单为我们提供的命令行环境，来实现在VS Code的终端中引入OneAPI环境。</p>
<p><img src="Fortran-Programming-in-Windows/images/OneAPI-CMD.png" alt="OneAPI-CMD" /></p>
<p>打开64位命令行工具快捷键的属性（作者的OneAPI安装在D盘，读者自行根据自身情况而定），解析其目标：</p>
<pre><code class="language-sh">%ComSpec% /E:ON /K &quot;&quot;D:\Program Files (x86)\Intel\oneAPI\setvars.bat&quot; intel64 vs2019&quot;
</code></pre>
<p>此处的<code>%ComSpec%</code>指的是Windows系统的<code>CMD.exe</code>终端，实际上该快捷方式为了运行预设<code>*.bat</code>脚本，并传入命令行参数如<code>intel64 vs2019</code>来临时导入OneAPI
运行需要的环境变量，如<code>.dll</code>和<code>.lib</code>依赖和<code>.exe</code>引用。</p>
<h3 id="自我实现"><a class="header" href="#自我实现">自我实现</a></h3>
<p>知道了这层原因，我们可以灵活地创建一个脚本，比如<code>set-ifort.bat</code>🚀来包含这个目标命令，将其置于我们的环境路径中，在需要<code>ifort</code>编译器时，在VS Code中的终端中
输入<code>set-ifort</code>启动<code>ifort</code>环境，这不算完美：1. 每次都需要手动启动<code>ifort</code>环境；2. <code>ifort</code>环境启动脚本是仅适应于<code>CMD</code>语法的。</p>
<blockquote>
<p>🔰 提示：不必非常强迫症，在实际工作时，有解决方案是第一要义，也许以后有更好的使用方式。<br>
如果<code>ifort</code>环境是你的刚需，建议将<code>set-ifort</code>脚本运行写入<code>pwsh</code>或者<code>bash</code>的启动任务脚本中。</p>
</blockquote>
<pre><code class="language-sh"># set-ifort.bat
%ComSpec% /E:ON /K &quot;&quot;D:\Program Files (x86)\Intel\oneAPI\setvars.bat&quot; intel64 vs2019&quot;
</code></pre>
<h3 id="ifortfpm的简单示例"><a class="header" href="#ifortfpm的简单示例"><code>ifort+fpm</code>的简单示例</a></h3>
<p>我们使用<code>fpm</code>调用<code>ifort</code>运行这个示例代码，如果我们想从<code>ifort</code>的<code>CMD</code>环境换回熟悉的<code>bash</code>和<code>pwsh</code>，可以选择添加额外的终端，或者在终端中输入<code>bash</code>和<code>pwsh</code>。<br>
当我们需要<code>ifort</code>时，再输入<code>set-ifort</code>即可，同理，这种方式未来有有望在VS Code中使用基于<code>Conda</code>环境的<code>LFortran</code>。</p>
<pre><code class="language-sh">fpm new --app hello_world &amp;&amp; cd hello_world  # 创建fpm示例
code .      # 使用VS Code打开本地文件夹
set-ifort   # 启动ifort环境
fpm run --compiler ifort  # 让fpm使用ifort环境编译代码
</code></pre>
<p><img src="Fortran-Programming-in-Windows/images/OneAPI-in-Code.png" alt="OneAPI-in-Code" /></p>
<blockquote>
<p>🔰 提示：对<code>ifort</code>来说，遗憾的是<code>fpm</code>默认选择使用<code>gfortran</code>作为构建它本身和构建生态的编译器，未来的<code>LFortran</code>也能成为Fortran开源编译器的主将，没办法开源
社区使用开源编译器更便捷。除非未来<code>OneAPI</code>为用户提供完善的CI（持续集成）环境，并且在<code>fpm</code>逐渐成熟的时候，不犹豫地资助<code>fpm</code>，否则缺席Fortran开源的<code>OneAPI</code>会受到无意的
“歧视”，因为未来Fortran的生态包，首先默认是开源编译器语法通过的。</p>
</blockquote>
<h2 id="其他链接"><a class="header" href="#其他链接">其他链接</a></h2>
<ul>
<li><a href="https://www.bilibili.com/video/BV1oh411o7AT?p=2">地球屋里老师：Fortran编译器及相关软件安装操作</a></li>
<li><a href="https://www.bilibili.com/video/BV1XD4y1S7jz?spm_id_from=333.999.0.0">地球屋里老师：Windows系统下Fortran编程</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="拥抱开源高效使用现代fortran"><a class="header" href="#拥抱开源高效使用现代fortran">拥抱开源，高效使用现代Fortran</a></h1>
<h2 id="使用开源"><a class="header" href="#使用开源">使用开源</a></h2>
<p>个人的能力是有限的，重复设计车轮子也是不合理的，所以我们可以大胆地拥抱开源代码，开源代码来自开源开发者，<strong>为更多的开发者赋能</strong>。</p>
<p>开源代码是<strong>免费获取</strong>的，但它们一般是<strong>有版权的</strong>，本教程倾向于介绍<strong>宽松开源许可证</strong>的开源代码，这对用户来说是友好型的。</p>
<p>希望读者注意<strong>养成遵循开源许可证的习惯</strong>，这是促成开源代码繁荣的正确路径——尊重别人的劳动，别人尊重我的劳动，开源的事大家一起解决。</p>
<ul>
<li><a href="https://opensource.org/licenses">开源倡议</a></li>
</ul>
<h2 id="工业化代码生产"><a class="header" href="#工业化代码生产">工业化代码生产</a></h2>
<p>如果我们做的不是个人项目，是正规的项目，比如商业开发。不慎重地、无限制地引入开源代码或者整个仓库的代码是会造成很大的开发负担的，所以请慎重地思考你的需求。</p>
<h2 id="构建工具fpm说明"><a class="header" href="#构建工具fpm说明">构建工具（fpm）说明</a></h2>
<p>我们相信代码生态十分重要，生态需要开源组织实体，<code>fortran-lang/fpm</code>有成为Fortran生态基石的潜力。<br>
所以，本章节开源代码采用<code>fpm</code>来构建和演示，但迁移到其它生产环境中也是简单的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为程序设置配置文件toml"><a class="header" href="#为程序设置配置文件toml">为程序设置配置文件：TOML</a></h1>
<p>TOML官网🎯：<a href="https://toml.io/cn/">https://toml.io/cn/</a><br>
TOML-F仓库（许可证：Apache License v2或者MIT License）：<a href="https://github.com/toml-f/toml-f">https://github.com/toml-f/toml-f</a></p>
<p>TOML（Tom的（语义）明显、（配置）最小化的语言）主要被设计为程序的配置文件，简单易用，典型地被fpm、cargo、julia作为代码包的配置文件。<br>
TOML也可被用作有限制性的、数据序列化的数据存储文件。</p>
<p><code>toml-f</code>是Fortran语言的TOML解析实现，我们可以使用它作为Fortran程序的配置文件。</p>
<div align="center">
<img src="Using-Open-Source-Code/media/toml-f-logo.png" alt="TOML-Fortran" width="150">
</div>
<h2 id="toml-f读取toml的api"><a class="header" href="#toml-f读取toml的api"><code>toml-f</code>读取toml的API</a></h2>
<p>在演示<code>toml-f</code>示例之前，我们来熟悉一（亿）下<code>toml-f</code>的API😎。</p>
<h3 id="toml_parse解析toml"><a class="header" href="#toml_parse解析toml"><code>toml_parse</code>：解析<code>toml</code></a></h3>
<p>从字符串（<code>character(:), allocatable</code>）或者文件单元号（<code>unit</code>）读取toml信息，这是解析toml内容的第一步。</p>
<pre><code class="language-fortran">call toml_parse(table, in [, error])
</code></pre>
<table><thead><tr><th>变量</th><th>类型</th><th>意义</th></tr></thead><tbody>
<tr><td><code>table</code></td><td><code>toml_table</code>类型，<code>allocatable</code>和<code>intent(out)</code></td><td>toml表格实例</td></tr>
<tr><td><code>in</code></td><td><code>integer</code>或者<code>character(:), allocatable</code>类型，<code>intent(in)</code></td><td>控制从文件单元号，或字符串中读取toml信息</td></tr>
<tr><td><code>error</code></td><td><code>toml_error</code>类型，<code>intent(out)</code>和<code>optional</code></td><td>错误提示</td></tr>
</tbody></table>
<h3 id="get_value读取变量的值"><a class="header" href="#get_value读取变量的值"><code>get_value</code>：读取变量的值</a></h3>
<p>从toml表格中读取确定键（key）的值（value）。</p>
<pre><code class="language-fortran">call get_value(table [, pos], ptr [, requested/default, stat])
</code></pre>
<table><thead><tr><th>变量</th><th>类型</th><th>意义</th></tr></thead><tbody>
<tr><td><code>table</code></td><td><code>toml_table/toml_array/toml_keyval</code>类型，<code>intent(inout)</code></td><td>toml表格实例/数组指针/键值指针</td></tr>
<tr><td><code>pos</code></td><td><code>toml_array/toml_key/integer</code>类型，<code>intent(in)</code></td><td>toml表格中的位置</td></tr>
<tr><td><code>ptr</code></td><td><code>integer</code>或者<code>character(:), allocatable</code>类型，<code>intent(in)</code></td><td>变量的值，或者子表格的指针</td></tr>
<tr><td><code>requested</code></td><td><code>logical</code>类型，<code>intent(in)</code>和<code>optional</code></td><td>是否请求在toml表格中添加默认值</td></tr>
<tr><td><code>default</code></td><td><code>real/integer/logical/character(*)</code>类型，<code>intent(in)</code></td><td>读取toml信息时，信息不存在，预设的默认值</td></tr>
<tr><td><code>stat</code></td><td><code>integer</code>类型，<code>intent(out)</code>和<code>optional</code></td><td>返回<code>0</code>为成功</td></tr>
</tbody></table>
<h3 id="destory析构toml缓存可忽略"><a class="header" href="#destory析构toml缓存可忽略"><code>destory</code>：析构<code>toml</code>缓存（可忽略）</a></h3>
<p>在读取完toml信息，我们<strong>可选地</strong>析构<code>toml_table</code>内的内容。</p>
<pre><code class="language-fortran">call table%destory()
</code></pre>
<table><thead><tr><th>变量</th><th>类型</th><th>意义</th></tr></thead><tbody>
<tr><td><code>table</code></td><td><code>toml_table</code>类型</td><td>toml表格实例</td></tr>
</tbody></table>
<blockquote>
<p>🔰 除非你在某个<code>module</code>内声明了一个<code>module</code>内的全局<code>toml_table</code>，要节约内存，否则，<strong>这个析构例程请大胆地忽略它</strong>。
因为在单元例程中的<code>toml_table</code>类型变量在例程结束后，就会结束其生命周期。</p>
</blockquote>
<h2 id="演示toml-f库的读取功能"><a class="header" href="#演示toml-f库的读取功能">演示<code>toml-f</code>库的读取功能</a></h2>
<pre><code class="language-sh">cd workspace  # 切换到你常用的工作区间
fpm new --app toml-demo  # 创建fpm项目
cd toml-demo &amp;&amp; code .   # 切换到`toml-demo`文件夹，并使用vs code打开它
</code></pre>
<p>我们创建了一个<code>toml-demo</code>工程，使用vs code打开了它，我们可以在fpm工程的<code>fpm.toml</code>文件中添加以下语句，以使用<code>toml-f</code>：</p>
<pre><code class="language-toml">[dependencies]
toml-f = { git=&quot;https://github.com/toml-f/toml-f.git&quot; }
</code></pre>
<p>在<code>toml-f</code>仓库的<a href="https://github.com/toml-f/toml-f#usage">README.md中</a>🕹提供了一个简单的示例。我们自己写个示例进行演示：</p>
<p><img src="Using-Open-Source-Code/media/toml-f-demo.png" alt="toml-demo" /></p>
<p>我们读取了所有toml内的数据，读取结果全部符合预期，程序正常退出了🚀。</p>
<h3 id="示例代码"><a class="header" href="#示例代码">示例代码</a></h3>
<pre><code class="language-fortran">program main

    use tomlf, only: toml_table, get_value, toml_parse, toml_array, len
    implicit none
    type(toml_table), allocatable :: intable
    type(toml_table), pointer :: subtable
    type(toml_array), pointer :: array
    integer :: unit, i, z

    !&gt; 目标读取变量
    character(:), allocatable :: name
    integer, allocatable :: x(:)
    real :: y

    open (newunit=unit, file=&quot;data.toml&quot;, status=&quot;old&quot;)

    !&gt; 解析toml文件
    call toml_parse(intable, unit)

    !&gt; 读取主表根目录的各个值
    
    call get_value(intable, &quot;name&quot;, name)
    call check(name == &quot;toml-demo&quot;, &quot;`name=='toml-demo'` failed&quot;)

    call get_value(intable, &quot;x&quot;, array)
    if (len(array) == 3) then
        allocate (x(3))

        do i = 1, 3

            call get_value(array, i, x(i))

        end do

        call check(all(x == [1, 2, 3]), &quot;`x == [1, 2, 3]` failed&quot;)

    else
        error stop &quot;`x`数组长度不等于3&quot;
    end if

    !&gt; 读取子表的各个值
    call get_value(intable, &quot;foo&quot;, subtable)
    call get_value(subtable, &quot;y&quot;, y)
    call check(abs(y - 10.0) &lt; 1.0E-6, &quot;`y == 10.0` failed&quot;)

    !&gt; 读取一个不存在的值
    call get_value(intable, &quot;z&quot;, z, stat=i)
    !&gt; *注意*：z值不存在，但i返回成功值`0`
    call check(i == 0, &quot;`i == 0` failed&quot;)

    !&gt; 读取一个不存在的值，但提供默认值
    call get_value(intable, &quot;z&quot;, z, 1, stat=i)
    call check(i == 0, &quot;`i == 0` failed&quot;)
    !&gt; 值不存在，但提供默认值，则z返回默认值
    call check(z == 1, &quot;`z == 1` failed&quot;)

    print *, &quot;读取结束，程序正常退出 ^_^&quot;
contains

    !&gt; 断言与测试
    subroutine check(condition, msg)
        logical, intent(in) :: condition     !! 测试条件
        character(len=*), intent(in) :: msg  !! 测试失败时的消息
        if (condition) return
        error stop msg
    end subroutine check

end program main
</code></pre>
<pre><code class="language-toml"># data.toml
name = &quot;toml-demo&quot;
x = [1, 2, 3]

[foo]
y = 10.0
</code></pre>
<h2 id="说明"><a class="header" href="#说明">说明</a></h2>
<pre><code class="language-fortran">module tomlf
    public :: get_value, set_value  !! 读取、写入值
    public :: toml_parse            !! 解析toml
    public :: toml_error, toml_stat !! toml-f辅助类型
    public :: toml_serializer       !! toml-f序列化例程
    public :: toml_table, toml_array, toml_key, is_array_of_tables, new_table, add_table, add_array, len
                                    !! toml-f辅助例程
    public :: sort                  !! toml-f排序
    public :: tomlf_version_string, tomlf_version_compact, get_tomlf_version  !! toml-f版本管理例程
end module tomlf
</code></pre>
<p><code>toml-f</code>的API可以在<a href="https://toml-f.github.io/toml-f/"><code>https://toml-f.github.io/toml-f/</code></a>找到，也可以直接阅读源码，非常推荐阅读它的<a href="https://github.com/toml-f/toml-f/tree/main/test/tftest">单元测试源码</a>，里面有着很全的API使用。</p>
<p>你可以模仿<code>fpm.toml</code>中toml的写法，或者去<a href="https://toml.io/cn/">TOML官网</a>查阅toml语法。</p>
<p>我们先学习如何使用<code>toml-f</code>解析读取toml信息，在此过程中，我们逐渐熟悉其API的使用，读者如果有<strong>输出toml</strong>的需求，很容易理解使用<code>toml-f</code>写入toml。</p>
<p>需要注意的有两点：</p>
<ul>
<li><code>toml</code>与<code>json</code>的转换在<a href="https://github.com/toml-f/toml-f/tree/main/test"><code>toml-f</code>的单元测试</a>中提供了代码。<br>
<code>json-fortran</code>（许可证：类似BSD）：<a href="https://github.com/jacobwilliams/json-fortran">https://github.com/jacobwilliams/json-fortran</a></li>
<li>从toml文件中尝试解析不存在的键值对，<code>toml-f</code>不认为是错误，所以请读取变量的设置默认值。</li>
<li>在手动设置<code>.toml</code>内容时，注意整型和浮点型的区别，<code>x = 1</code>中<code>x</code>始终被认为是整型，<code>x = 1.0</code>中<code>x</code>才是浮点型，这点往往会被忽视。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用openblas进行矩阵计算"><a class="header" href="#使用openblas进行矩阵计算">使用OpenBLAS进行矩阵计算</a></h1>
<p>OpenBLAS官网：<a href="https://www.openblas.net/">https://www.openblas.net/</a><br>
BLAS网站：<a href="http://www.netlib.org/blas/#_blas_routines">http://www.netlib.org/blas/#_blas_routines</a>🎯</p>
<p>BLAS（Basic Linear Algebra Subprograms）是著名的基础线性代数库，我们推荐使用被深度优化的OpenBLAS来进行线性代数计算。</p>
<p>BLAS库中的函数操作根据运算对象分为三类，它们的时间复杂度依次递增：</p>
<ul>
<li>Level 1：向量间的运算（1979年~）；</li>
<li>Level 2：矩阵与向量的运算（1988年~）；</li>
<li>Level 3：矩阵间的运算（1990年~）。</li>
</ul>
<div align="center">
<img src="Using-Open-Source-Code/media/openblas-logo.png" alt="OpenBLAS Logo" width="220">
</div>
<h2 id="安装openblas"><a class="header" href="#安装openblas">安装OpenBLAS</a></h2>
<p>我们使用MSYS2软件能非常便捷地安装OpenBLAS（假设你已经安装了MSYS2，并且配置了系统环境变量）：</p>
<pre><code class="language-sh">pacman -Ss openblas  # 查询名字中含“openblas”字符的包
pacman -S  ucrt64/mingw-w64-ucrt-x86_64-openblas  # 安装openblas
</code></pre>
<h2 id="blaslapack的接口说明"><a class="header" href="#blaslapack的接口说明">Blas/Lapack的接口说明</a></h2>
<ul>
<li>函数或子程序命名格式为<code>ABBCCC</code> ，其中A表示数据类型，BB表示矩阵类型，CCC表示运算类型(不足三个一般写CC)。</li>
<li>A 有四种(S/D/C/Z)，S 表示单精度浮点数<code>real(4)</code>，D表示双精度浮点数<code>real(8)</code>，C表示单精度复数<code>complex(4)</code>,Z表示双精度复数<code>complex(8)</code>。</li>
<li>BB 例如 ge/一般矩阵，sy/对称矩阵，he/厄密矩阵等等，全部的类型可以在该网站查找， <a href="https://www.netlib.org/lapack/lug/node24.html">矩阵类型</a>。</li>
<li>CCC 例如 svd/svd分解，mm/矩阵相乘，ev/特征值问题等等。</li>
<li>组合起来，例如 dgemm/(双精度一般矩阵的乘法)，dsyev/(双精度对称矩阵的特征值问题)。关于全部接口的描述，参考网站， <a href="http://www.netlib.org/lapack/explore-html/modules.html">Blas/Lapack接口</a>。</li>
<li>调用时,查看对应的接口，了解函数或者子程序的返回值，填写与之对应的参数，了解报错时返回值的含义。</li>
<li>目前并不支持四精度，如果需要，可自行下载源代码替换类型。</li>
</ul>
<h2 id="演示openblas求解线性方程组"><a class="header" href="#演示openblas求解线性方程组">演示：OpenBLAS求解线性方程组</a></h2>
<pre><code class="language-sh">cd workspace  # 切换到你常用的工作区间
fpm new --app solve-demo  # 创建fpm项目
cd solve-demo &amp;&amp; code .   # 切换到`solve-demo`文件夹，并使用vs code打开它
</code></pre>
<p>不出意外的话，我们创建了一个<code>solve-demo</code>工程，并且使用vs code打开了它，我们在<code>fpm.toml</code>中添加声明来引用安装的OpenBLAS链接库：</p>
<pre><code class="language-toml">[build]
link = [&quot;openblas&quot;]
</code></pre>
<p><img src="Using-Open-Source-Code/media/openblas-demo.png" alt="OpenBLAS演示" /></p>
<p>通过使用双精度的线性方程组求解例程<code>dgesv</code>，我们求解到了预设方程组<code>Ax = b</code>的正确结果🚀：<code>x = [1.0; 3.0]</code>。</p>
<blockquote>
<p>🔰 提示：这只是一个简单的演示，更多的例程使用还需要用户自行前往官方网站查询帮助文档。<br>
做工程不是搞艺术，而且用户是被提供服务一方，不要过于纠结API接口的美观与否，形成可行的解决方案始终是第一要义。</p>
</blockquote>
<h3 id="示例代码-1"><a class="header" href="#示例代码-1">示例代码</a></h3>
<pre><code class="language-fortran">program main

    use, intrinsic :: iso_fortran_env, only: real64
    implicit none
    real(real64) :: A(2, 2), b(2, 1)  !! 线性方程组矩阵
    integer :: ipiv(2)  !! openblas中的行列交换标记、工作数组
    integer :: info     !! openblas中的返回值

    A = reshape([1.0, 3.0, 2.0, 4.0], [2, 2])
    b = reshape([7.0, 15.0], [2, 1])

    !&gt; `dgesv`求解双精度线性方程组
    call dgesv(2, 1, A, 2, ipiv, b, 2, info)

    !&gt; 最简单的测试
    call check(info == 0, &quot;`info == 0` failed&quot;)
    call check(abs(b(1, 1) - 1.0) &lt; 1.0E-6, &quot;`b(1,1) == 1.0` failed&quot;)
    call check(abs(b(2, 1) - 3.0) &lt; 1.0E-6, &quot;`b(2,1) == 3.0` failed&quot;)

    print *, &quot;结果符合预期，正常退出 ^_^&quot;
contains

    !&gt; 断言与测试
    subroutine check(condition, msg)
        logical, intent(in) :: condition     !! 测试条件
        character(len=*), intent(in) :: msg  !! 测试失败时的消息
        if (condition) return
        error stop msg
    end subroutine check

end program main
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用m_attr输出彩色控制台文本"><a class="header" href="#使用m_attr输出彩色控制台文本">使用M_attr输出彩色控制台文本</a></h1>
<p>M_attr仓库（许可证：MIT）：<a href="https://github.com/urbanjost/M_attr">https://github.com/urbanjost/M_attr</a></p>
<p>M_attr是urbanjost的开源项目，使用ANSI码escape序列来输出终端彩色文本属性。</p>
<div align="center">
<img src="Using-Open-Source-Code/media/M_attr.png" alt="M_attr" width="150">
</div>
<h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<p>M_attr之所以被推荐，是因为它足够简单，巧妙使用类似HTML的标记化风格来控制输出文本的属性。</p>
<p>它的应用场景主要是：</p>
<ul>
<li>屏幕日志输出；</li>
<li>屏幕UI效果增强；</li>
<li>炫技。</li>
</ul>
<p>另外，urbanjost是一个资深的Fortran开源开发者。</p>
<h2 id="使用m_attr输出彩色控制台文本-1"><a class="header" href="#使用m_attr输出彩色控制台文本-1">使用<code>M_attr</code>输出彩色控制台文本</a></h2>
<p><code>M_attr</code>库可以在 GBK 编码的 CMD 或 UTF8 编码的 Bash 上正确运行。</p>
<h3 id="attr函数"><a class="header" href="#attr函数"><code>attr</code>函数</a></h3>
<p><code>M_attr</code>库的精髓即<code>attr</code>函数，我们建立一个简单的示例来演示它：</p>
<pre><code class="language-sh">cd workspace  # 切换到你常用的工作区间
fpm new --app m_attr-demo  # 创建fpm项目
cd m_attr-demo &amp;&amp; code .   # 切换到`m_attr-demo`文件夹，并使用vs code打开它
</code></pre>
<p>我们创建了一个<code>m_attr-demo</code>工程，使用vs code打开了它，我们可以在fpm工程的<code>fpm.toml</code>文件中添加以下语句，以使用<code>M_attr</code>：</p>
<pre><code class="language-toml">[dependencies]
M_attr = { git=&quot;https://github.com/urbanjost/M_attr.git&quot; }
</code></pre>
<p><img src="Using-Open-Source-Code/media/M_attr-demo.png" alt="M_attr-demo" /></p>
<p>我们可以使用属性的全称和缩写来标记目标文本，大写属性表示背景色，小写属性表示前景色。</p>
<h3 id="示例代码-2"><a class="header" href="#示例代码-2">示例代码</a></h3>
<pre><code class="language-fortran">program demo_M_attr
    use M_attr, only: attr
    print *, attr('&lt;GREEN&gt;&lt;bold&gt;&lt;white&gt; Hello World!&lt;/white&gt;&lt;/bold&gt;&lt;/GREEN&gt;&lt;reset&gt;')
    ! or
    print *, attr('&lt;G&gt;&lt;bo&gt;&lt;w&gt; Hello World!')
end program demo_M_attr
</code></pre>
<h2 id="说明-1"><a class="header" href="#说明-1">说明</a></h2>
<p><code>attr</code>函数是核心函数，除此之外，还有一些辅助函数，可以对内部实现效果进行自定义调整，建议深度使用者细读源代码和帮助文档。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用test-drive测试你的代码"><a class="header" href="#使用test-drive测试你的代码">使用<code>test-drive</code>测试你的代码</a></h1>
<p><code>test-drive</code>库（许可证：MIT或Apache 2.0）：<a href="https://github.com/fortran-lang/test-drive">https://github.com/fortran-lang/test-drive</a></p>
<p>在代码开发中，合理的单元测试可以解放自己的双手，让计算机使用事先写好的测试代码自动化验证你的业务代码。</p>
<p><code>test-drive</code>原为Sebastian Ehlert开发的单元测试库，质量很高，现在已经移交到Fortran-lang组织命名空间下。</p>
<div align="center">
<img src="Using-Open-Source-Code/media/test-drive.png" alt="test-drive" width="150">
</div>
<h2 id="简介-1"><a class="header" href="#简介-1">简介</a></h2>
<p>test-drive现在由Fortran-lang组织维护开发，它的使用相对简单，巧妙使用回调函数，设计较为合理，且适应于配合fpm使用。</p>
<p>它的应用场景主要是：</p>
<ul>
<li>函数库的开发（简单）；</li>
<li>可执行程序的开发（复杂些）。</li>
</ul>
<p>另外，<a href="https://github.com/awvwgk">Sebastian Ehlert</a>也是一名资深的Fortran开源开发者。</p>
<h2 id="test-drive演示"><a class="header" href="#test-drive演示"><code>test-drive</code>演示</a></h2>
<p>我们使用<code>test-drive</code>库中<code>README.md</code>的示例，进行演示：</p>
<pre><code class="language-sh">cd workspace  # 切换到你常用的工作区间
fpm new --app test-drive-demo  # 创建fpm项目
cd test-drive-demo &amp;&amp; code .   # 切换到`test-drive-demo`文件夹，并使用vs code打开它
</code></pre>
<p>我们创建了一个<code>test-drive-demo</code>工程，使用vs code打开了它，我们可以在fpm工程的<code>fpm.toml</code>文件中添加以下语句，以使用<code>test-drive</code>：</p>
<pre><code class="language-toml">[dependencies]
test-drive = { git=&quot;https://github.com/fortran-lang/test-drive.git&quot; }
</code></pre>
<p><img src="Using-Open-Source-Code/media/test-drive-demo.png" alt="test-drive-demo" /></p>
<p>通过在分类的module里设置相关单元测试，建立一个或多个主测试程序，使用<code>fpm test</code>命令，对业务代码进行单元测试。</p>
<p>单元测试的实现<strong>核心是判断</strong>，在这里体现为<code>check</code>子例程，当<code>condition</code>为不符合预期的<code>.false.</code>时，程序中断，提示用户，计算结果不符合预期。</p>
<p>这在我们开发和修改业务代码内容时，提供了一个检查预期待的途径，帮助我们节省人力物力。这在代码开发中，也叫做TDD（test-drived developement，测试驱动开发）。</p>
<h2 id="示例代码-3"><a class="header" href="#示例代码-3">示例代码</a></h2>
<p><strong>主测试程序</strong></p>
<pre><code class="language-fortran">program tester
    use, intrinsic :: iso_fortran_env, only: error_unit
    use testdrive, only: run_testsuite, new_testsuite, testsuite_type
    use test_suite1, only: collect_suite1
    implicit none
    integer :: stat, is
    type(testsuite_type), allocatable :: testsuites(:)
    character(len=*), parameter :: fmt = '(&quot;#&quot;, *(1x, a))'

    stat = 0

    testsuites = [ &amp;
                 new_testsuite(&quot;suite1&quot;, collect_suite1) &amp;
                 ]

    do is = 1, size(testsuites)
        write (error_unit, fmt) &quot;Testing:&quot;, testsuites(is)%name
        call run_testsuite(testsuites(is)%collect, error_unit, stat)
    end do

    if (stat &gt; 0) then
        write (error_unit, '(i0, 1x, a)') stat, &quot;test(s) failed!&quot;
        error stop
    end if

end program tester
</code></pre>
<p><strong>单元测试模块</strong></p>
<pre><code class="language-fortran">module test_suite1
    use testdrive, only: new_unittest, unittest_type, error_type, check
    implicit none
    private

    public :: collect_suite1

contains

    !&gt; Collect all exported unit tests
    subroutine collect_suite1(testsuite)
        !&gt; Collection of tests
        type(unittest_type), allocatable, intent(out) :: testsuite(:)

        testsuite = [ &amp;
                    new_unittest(&quot;valid&quot;, test_valid), &amp;
                    new_unittest(&quot;invalid&quot;, test_invalid, should_fail=.true.) &amp;
                    ]

    end subroutine collect_suite1

    subroutine test_valid(error)
        type(error_type), allocatable, intent(out) :: error
        
        call check(error, 2, 2)
        if (allocated(error)) return
        call check(error, .true.)
        !&gt; 最后一个return可有可无，已经到了最后，程序自己会return的
        if (allocated(error)) return
        
    end subroutine test_valid

    subroutine test_invalid(error)
        type(error_type), allocatable, intent(out) :: error
        
        call check(error, 1, 2)
        if (allocated(error)) return
        call check(error, .false.)
        if (allocated(error)) return
        
    end subroutine test_invalid

end module test_suite1
</code></pre>
<h2 id="说明-2"><a class="header" href="#说明-2">说明</a></h2>
<p><code>test-drive</code>设计合理，源码很值得学习。
除了该库以外，还有很多其他优秀的Fortran单元测试库，此处暂不做介绍。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-lua-语言及其脚本实现-fortran-程序的热重载"><a class="header" href="#使用-lua-语言及其脚本实现-fortran-程序的热重载">使用 Lua 语言及其脚本实现 Fortran 程序的热重载</a></h1>
<p><code>fortran-lua53</code>🔥仓库 (许可证: ISC，类似BSD-2): <a href="https://github.com/interkosmos/fortran-lua53">https://github.com/interkosmos/fortran-lua53</a></p>
<p><code>fortran-lua</code>是 <a href="https://github.com/interkosmos">Philipp</a> 编写的开源项目，它是 Lua 5.3 的 Fortran 接口。</p>
<div align="center">
<img src="Using-Open-Source-Code/media/luaa.gif" alt="Lua" width="150">
</div>
<h2 id="lua-简介"><a class="header" href="#lua-简介">Lua 简介</a></h2>
<p>Lua 由 C 语言编程，可以作为单独的 Lua 解释器或 C 语言函数库，是一名优秀小巧的函数式动态语言，其速度是动态语言中 Top 0 级别的，另外，Lua 语言是罕见的由发展中国家设计开发出的著名语言。</p>
<p>它的主要应用场景是:</p>
<ul>
<li>为编译型语言带来灵活性;</li>
<li>为编译型语言代码可拓展性，这一点体现在热重载能力。</li>
</ul>
<blockquote>
<p>🔰 热重载: 一般情况下，当不具备任何反射特性的编译型语言一旦完成编译，实现部署，中途如果发现 Bug ，则需要重新修改源码，再进行编译部署，且需要中断之前正在运行的含 Bug 的程序。<br />
但是，通过 Lua 脚本，比如 Fortran ，可以借助 Lua 只实现 Lua 脚本的内容，就能一定程度改变程序的后续运行过程，可以一定程度避免中断运行。<br />
这点与配置文件似乎有着异曲同工之妙，但配置文件主要负责程序数据的配置，而 Lua 脚本则更体现出从函数（方法）上改变程序的运行业务，且更灵活，数据配置亦可。<br />
所以，Lua 在游戏开发行业用的较多，可以为上线的游戏快速推送 Lua 补丁，性能又好，体积又小。</p>
</blockquote>
<h2 id="演示-使用-lua-脚本改变程序的运行效果"><a class="header" href="#演示-使用-lua-脚本改变程序的运行效果">演示: 使用 Lua 脚本改变程序的运行效果</a></h2>
<p>我们演示一下在代码编写过程中写错了 Lua 业务，然后在不修改 Fortran 代码、不中断程序运行的情况下，实现 Lua 业务修改和正确运行：</p>
<pre><code class="language-sh">cd workspace  # 切换到你常用的工作区间
fpm new --app lua-demo  # 创建fpm项目
cd lua-demo &amp;&amp; code .   # 切换到`lua-demo`文件夹，并使用vs code打开它
</code></pre>
<p>我们创建了一个<code>lua-demo</code>工程，使用vs code打开了它，我们可以在fpm工程的<code>fpm.toml</code>文件中添加以下语句，以使用<code>fortran-lua53</code>：</p>
<pre><code class="language-toml">[dependencies]
fortran-lua53 = { git = &quot;https://github.com/interkosmos/fortran-lua53.git&quot; }
</code></pre>
<p><img src="Using-Open-Source-Code/media/lua_false.png" alt="错误业务" /></p>
<p>上图，我们“不小心”在 Lua 脚本中写了一个错误的<code>times</code>函数（粗心的程序员写成了加法函数），可是程序已经运行了，幸亏这个 Bug 不会导致程序崩溃，我们得赶紧修改它，并且将这个补丁发送给用户。</p>
<pre><code class="language-sh"> 5 * 5 =           10
 按回车继续运行..
</code></pre>
<p><img src="Using-Open-Source-Code/media/lua_true.png" alt="正确业务" /></p>
<p>我们在程序运行的间隙，修改了<code>times</code>函数的业务，并且推送给用户运行环境，此后程序业务得到正常合理运行。</p>
<pre><code class="language-sh"> 5 * 5 =           25
 按回车继续运行..
</code></pre>
<p>我们能看到，Lua 脚本的强大之处，尤其是对强编译型语言的特殊需求，它使得程序变得更灵活，相当于用户业务程序实时自带了一个实时高效的 Lua 解释器。</p>
<p>大多数情况下，这个特性常规用户是不太需要的，但确实为编程提供了一种特色强烈的可能性，跨语言交互和热重载。</p>
<h2 id="代码"><a class="header" href="#代码">代码</a></h2>
<pre><code class="language-fortran">program main
    
    use, intrinsic :: iso_c_binding, only: c_ptr
    use lua
    implicit none
    !&gt; C 指针, 可以指向任何类型的 C 对象
    type(c_ptr) :: l
    integer :: rc
    
    do
        !&gt; 启动 Lua 虚拟机
        l = lual_newstate()
        call lual_openlibs(l)
        rc = lual_dofile(l, &quot;times.lua&quot;)
        rc = lua_getglobal(l, &quot;times&quot;)
        
        !&gt; 推送参数值
        call lua_pushinteger(l, 5)
        call lua_pushinteger(l, 5)
        rc = lua_pcall(l, 2, 1, 0)
        
        !&gt; 获取返回值
        rc = lua_tointeger(l, -1)
        call lua_pop(l, 1)
        
        print *, &quot;5 * 5 = &quot;, rc
        print *, &quot;按回车继续运行..&quot;
        read (*, *)
        
    end do
    
end program main
</code></pre>
<pre><code class="language-lua">-- 整数乘法
function times(a, b)  
    return a + b
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fortran-开发工具集助力开发者"><a class="header" href="#fortran-开发工具集助力开发者">Fortran 开发工具集助力开发者</a></h1>
<p>Fortran 是一门比较悠久的语言，它有一些特殊的工具集，协助 Fortran 程序员快速开发。</p>
<p>本文介绍这些开发工具，以便帮助用户提高开发效率，增加开发乐趣。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-fprettify-格式化你的代码"><a class="header" href="#使用-fprettify-格式化你的代码">使用 Fprettify 格式化你的代码</a></h1>
<h2 id="简介-2"><a class="header" href="#简介-2">简介</a></h2>
<p>Fprettify 是专用于 Fortran 的代码格式化工具。使用它可以解放我们的思想，使得代码保持统一的编程风格，使我们专注于代码业务。</p>
<p>仓库：<a href="https://github.com/pseewald/fprettify">https://github.com/pseewald/fprettify</a></p>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<p>首先我们需要先安装 Python 3 和 PIP，然后安装 Fprettify：</p>
<pre><code class="language-sh">pip install --upgrade fprettify
</code></pre>
<h2 id="使用-fprettify"><a class="header" href="#使用-fprettify">使用 Fprettify</a></h2>
<p>但我们写完 Fortran 代码后，我们可以通过命令行工具 Fprettify 来格式化代码：</p>
<pre><code class="language-sh">fprettify file.f90
</code></pre>
<p>更多的命令行参数可以使用 <code>fprettify --help</code> 查看。</p>
<pre><code class="language-sh">$ fprettify --help
usage: C:\msys64\ucrt64\bin\fprettify [-h] [-c CONFIG_FILE] [-i INDENT]
                                      [-l LINE_LENGTH] [-w {0,1,2,3,4}]
                                      [--whitespace-comma [WHITESPACE_COMMA]]
                                      [--whitespace-assignment [WHITESPACE_ASSIGNMENT]]
                                      [--whitespace-decl [WHITESPACE_DECL]]
                                      [--whitespace-relational [WHITESPACE_RELATIONAL]]
                                      [--whitespace-logical [WHITESPACE_LOGICAL]]
                                      [--whitespace-plusminus [WHITESPACE_PLUSMINUS]]
                                      [--whitespace-multdiv [WHITESPACE_MULTDIV]]
                                      [--whitespace-print [WHITESPACE_PRINT]]
                                      [--whitespace-type [WHITESPACE_TYPE]]
                                      [--whitespace-intrinsics [WHITESPACE_INTRINSICS]]
                                      [--strict-indent] [--enable-decl]
                                      [--disable-indent]
                                      [--disable-whitespace]
                                      [--enable-replacements] [--c-relations]
                                      [--case CASE CASE CASE CASE]
                                      [--strip-comments] [--disable-fypp]
                                      [--disable-indent-mod] [-d] [-s] [-S]
                                      [-r] [-e EXCLUDE] [-f FORTRAN]
                                      [--version]
                                      [path ...]

Auto-format modern Fortran source files. Config files ('.fprettify.rc') in the
home (~) directory and any such files located in parent directories of the
input file will be used. When the standard input is used, the search is
started from the current directory.

positional arguments:
  path                  Paths to files to be formatted inplace. If no paths
                        are given, stdin (-) is used by default. Path can be a
                        directory if --recursive is used. (default: ['-'])

optional arguments:
  -h, --help            show this help message and exit
  -c CONFIG_FILE, --config-file CONFIG_FILE
                        config file path (default: None)
  -i INDENT, --indent INDENT
                        relative indentation width (default: 3)
  -l LINE_LENGTH, --line-length LINE_LENGTH
                        column after which a line should end, viz. -ffree-
                        line-length-n for GCC (default: 132)
  -w {0,1,2,3,4}, --whitespace {0,1,2,3,4}
                        Presets for the amount of whitespace - 0: minimal
                        whitespace | 1: operators (except arithmetic),
                        print/read | 2: operators, print/read, plus/minus | 3:
                        operators, print/read, plus/minus, muliply/divide | 4:
                        operators, print/read, plus/minus, muliply/divide,
                        type component selector (default: 2)
  --whitespace-comma [WHITESPACE_COMMA]
                        boolean, en-/disable whitespace for comma/semicolons
                        (default: None)
  --whitespace-assignment [WHITESPACE_ASSIGNMENT]
                        boolean, en-/disable whitespace for assignments
                        (default: None)
  --whitespace-decl [WHITESPACE_DECL]
                        boolean, en-/disable whitespace for declarations
                        (requires '--enable-decl') (default: None)
  --whitespace-relational [WHITESPACE_RELATIONAL]
                        boolean, en-/disable whitespace for relational
                        operators (default: None)
  --whitespace-logical [WHITESPACE_LOGICAL]
                        boolean, en-/disable whitespace for logical operators
                        (default: None)
  --whitespace-plusminus [WHITESPACE_PLUSMINUS]
                        boolean, en-/disable whitespace for plus/minus
                        arithmetic (default: None)
  --whitespace-multdiv [WHITESPACE_MULTDIV]
                        boolean, en-/disable whitespace for multiply/divide
                        arithmetic (default: None)
  --whitespace-print [WHITESPACE_PRINT]
                        boolean, en-/disable whitespace for print/read
                        statements (default: None)
  --whitespace-type [WHITESPACE_TYPE]
                        boolean, en-/disable whitespace for select type
                        components (default: None)
  --whitespace-intrinsics [WHITESPACE_INTRINSICS]
                        boolean, en-/disable whitespace for intrinsics like
                        if/write/close (default: None)
  --strict-indent       strictly impose indentation even for nested loops
                        (default: False)
  --enable-decl         enable whitespace formatting of declarations ('::'
                        operator). (default: False)
  --disable-indent      don't impose indentation (default: False)
  --disable-whitespace  don't impose whitespace formatting (default: False)
  --enable-replacements
                        replace relational operators (e.g. '.lt.' &lt;--&gt; '&lt;')
                        (default: False)
  --c-relations         C-style relational operators ('&lt;', '&lt;=', ...)
                        (default: False)
  --case CASE CASE CASE CASE
                        Enable letter case formatting of intrinsics by
                        specifying which of keywords, procedures/modules,
                        operators and constants (in this order) should be
                        lowercased or uppercased - 0: do nothing | 1:
                        lowercase | 2: uppercase (default: [0, 0, 0, 0])
  --strip-comments      strip whitespaces before comments (default: False)
  --disable-fypp        Disables the indentation of fypp preprocessor blocks.
                        (default: False)
  --disable-indent-mod  Disables the indentation after module / program.
                        (default: False)
  -d, --diff            Write file differences to stdout instead of formatting
                        inplace (default: False)
  -s, --stdout          Write to stdout instead of formatting inplace
                        (default: False)
  -S, --silent, --no-report-errors
                        Don't write any errors or warnings to stderr (default:
                        False)
  -r, --recursive       Recursively auto-format all Fortran files in
                        subdirectories of specified path; recognized filename
                        extensions: .f, .for, .ftn, .f90, .f95, .f03, .fpp,
                        .F, .FOR, .FTN, .F90, .F95, .F03, .FPP (default:
                        False)
  -e EXCLUDE, --exclude EXCLUDE
                        File or directory patterns to be excluded when
                        searching for Fortran files to format (default: [])
  -f FORTRAN, --fortran FORTRAN
                        Overrides default fortran extensions recognized by
                        --recursive. Repeat this option to specify more than
                        one extension. (default: [])
  --version             show program's version number and exit

Args that start with '--' (eg. -i) can also be set in a config file (specified
via -c). Config file syntax allows: key=value, flag=true, stuff=[a,b,c] (for
details, see syntax at https://goo.gl/R74nmi). If an arg is specified in more
than one place, then commandline values override config file values which
override defaults.
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
