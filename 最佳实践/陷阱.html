<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>陷阱或缺陷 - Fortran 语言实战</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../说明.html"><strong aria-hidden="true">1.</strong> 关于</a></li><li class="chapter-item expanded "><a href="../最佳实践/关于本书.html"><strong aria-hidden="true">2.</strong> Fortran最佳实践</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../最佳实践/风格指导.html"><strong aria-hidden="true">2.1.</strong> Fortran风格指导</a></li><li class="chapter-item expanded "><a href="../最佳实践/浮点数.html"><strong aria-hidden="true">2.2.</strong> 浮点数</a></li><li class="chapter-item expanded "><a href="../最佳实践/整数除法.html"><strong aria-hidden="true">2.3.</strong> 整数除法</a></li><li class="chapter-item expanded "><a href="../最佳实践/模块与程序.html"><strong aria-hidden="true">2.4.</strong> 模块</a></li><li class="chapter-item expanded "><a href="../最佳实践/数组.html"><strong aria-hidden="true">2.5.</strong> 数组</a></li><li class="chapter-item expanded "><a href="../最佳实践/高维数组.html"><strong aria-hidden="true">2.6.</strong> 高维数组</a></li><li class="chapter-item expanded "><a href="../最佳实践/逐元.html"><strong aria-hidden="true">2.7.</strong> 逐元操作</a></li><li class="chapter-item expanded "><a href="../最佳实践/可分配数组.html"><strong aria-hidden="true">2.8.</strong> 可分配数组</a></li><li class="chapter-item expanded "><a href="../最佳实践/文件IO.html"><strong aria-hidden="true">2.9.</strong> 文件io</a></li><li class="chapter-item expanded "><a href="../最佳实践/回调函数.html"><strong aria-hidden="true">2.10.</strong> 回调函数</a></li><li class="chapter-item expanded "><a href="../最佳实践/类型重塑.html"><strong aria-hidden="true">2.11.</strong> 类型转换</a></li><li class="chapter-item expanded "><a href="../最佳实践/陷阱.html" class="active"><strong aria-hidden="true">2.12.</strong> 陷阱或缺陷</a></li></ol></li><li class="chapter-item expanded "><a href="../在Windows中进行Fortran编程/说明.html"><strong aria-hidden="true">3.</strong> 在Windows系统下进行Fortran编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../在Windows中进行Fortran编程/环境路径.html"><strong aria-hidden="true">3.1.</strong> 环境路径</a></li><li class="chapter-item expanded "><a href="../在Windows中进行Fortran编程/GFortran.html"><strong aria-hidden="true">3.2.</strong> 使用GFortran</a></li><li class="chapter-item expanded "><a href="../在Windows中进行Fortran编程/OneAPI.html"><strong aria-hidden="true">3.3.</strong> 使用OneAPI套件</a></li></ol></li><li class="chapter-item expanded "><a href="../使用开源代码/说明.html"><strong aria-hidden="true">4.</strong> 拥抱开源，高效使用现代Fortran</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../使用开源代码/TOML配置文件.html"><strong aria-hidden="true">4.1.</strong> 为程序设置配置文件：TOML</a></li><li class="chapter-item expanded "><a href="../使用开源代码/线性代数.html"><strong aria-hidden="true">4.2.</strong> 使用OpenBLAS进行矩阵计算</a></li><li class="chapter-item expanded "><a href="../使用开源代码/彩色控制台文本.html"><strong aria-hidden="true">4.3.</strong> 使用M_attr输出彩色控制台文本</a></li><li class="chapter-item expanded "><a href="../使用开源代码/单元测试.html"><strong aria-hidden="true">4.4.</strong> 使用test-drive测试你的代码</a></li><li class="chapter-item expanded "><a href="../使用开源代码/热重载.html"><strong aria-hidden="true">4.5.</strong> 使用 Lua 语言及其脚本实现 Fortran 程序的热重载</a></li></ol></li><li class="chapter-item expanded "><a href="../开发工具/说明.html"><strong aria-hidden="true">5.</strong> Fortran开发者编程工具集</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../开发工具/Fprettify.html"><strong aria-hidden="true">5.1.</strong> 使用 Fprettify 格式化你的代码</a></li><li class="chapter-item expanded "><a href="../开发工具/FORTLS.html"><strong aria-hidden="true">5.2.</strong> Fortran语言服务程序</a></li></ol></li><li class="chapter-item expanded "><a href="../变更日志-2022.html"><strong aria-hidden="true">6.</strong> 变更日志</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Fortran 语言实战</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/fortran-fans/Fortran-in-Action/tree/main/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                                        <a href="https://github.com/fortran-fans/Fortran-in-Action/edit/main/src/最佳实践/陷阱.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fortran-程序中的陷阱"><a class="header" href="#fortran-程序中的陷阱">Fortran 程序中的陷阱</a></h1>
<p>翻译原文网址 https://www.cs.rpi.edu/~szymansk/OOF90/bugs.html</p>
<p>多年来，我们在Fortran 90中犯了很多有趣的错误，想和大家分享。欢迎您的贡献和经验，以便能够分享您的痛苦。
这些“陷阱”令人讨厌，因为它们在某些机器上不会失败，而在其他机器上可能会失败（考虑到编译器和机器平台的各种组合）。</p>
<h2 id="可选参数的陷阱"><a class="header" href="#可选参数的陷阱">可选参数的陷阱</a></h2>
<p>在本例中，用一个可选参数来确定是否打印标题。</p>
<pre><code class="language-Fortran">subroutine print_char(this,header)
    character(len=*), intent (in) :: this
    logical, optional, intent (in) :: header
    ! THIS IS THE WRONG WAY
    if (present(header) .and. header) then
        print *, 'This is the header '
    endif
    print *, this
end subroutine print_char

subroutine print_char2(this,header)
    character(len=*), intent (in) :: this
    logical, optional, intent (in) :: header
    ! THIS IS THE RIGHT WAY
    if (present(header)) then
        if (header) print *, 'This is the header '
    endif
    print *, this
end subroutine print_char2
</code></pre>
<p><strong>解释</strong></p>
<p>第一种方法不安全，因为编译器可以在计算<code>present</code>函数之前计算<code>header</code>参数。如果<code>header</code>参数实际上不存在，可能会发生越界内存引用(<code>Segmentation fault - invalid memory reference.</code>)。</p>
<h2 id="intentout的陷阱"><a class="header" href="#intentout的陷阱">Intent(out)的陷阱</a></h2>
<pre><code class="language-fortran">program intent_gotcha
    type mytype
        integer :: x
        real,allocatable:: y
    end type mytype
    type (mytype) :: a
    a%x = 1 ; a%y = 2.
    call assign(a)
    ! a%y COULD BE UNDEFINED HERE
    print *, a%x , a%y
contains

    subroutine assign(this)
        type (mytype), intent (out) :: this
        ! THIS IS THE WRONG WAY
        this%x = 2
    end subroutine assign

    subroutine assign2(this)
        type (mytype), intent (out) :: this
        ! THIS IS THE RIGHT WAY
        this%x = 2 ; this%y = 2.
    end subroutine assign2

    subroutine assign3(this)
        type (mytype), intent (inout) :: this
        ! THIS IS THE RIGHT WAY
        this%x = 2 
    end subroutine assign3
end program intent_gotcha
</code></pre>
<p><strong>解释</strong></p>
<p>问题是，当<code>intent(out)</code>与派生类型一起使用时，过程中未分配的任何成员都可能在退出时变得未定义。例如，即使在进入该例程时定义了<code>%y</code>，但在退出时它可能会变得未定义，因为它从未在例程中分配过。教训是，当使用<code>intent(out)</code>时，派生类型的所有成员都应该在一个过程中指定。<code>Intent(out)</code>的行为类似于函数中的结果变量：必须分配所有成员。
或者，<strong>使用</strong><code>intent(inout)</code>。</p>
<h2 id="初始化局部变量的陷阱"><a class="header" href="#初始化局部变量的陷阱">初始化局部变量的陷阱</a></h2>
<pre><code class="language-fortran">real function kinetic_energy(v)
    real, dimension(:), intent(in) :: v
    integer i
    ! THIS IS THE WRONG WAY
    real :: ke = 0.0
    do i = 1, size(v)
        ke = ke + v(i)**2
    enddo
    kinetic_energy = .5*ke
end function kinetic_energy

real function kinetic_energy2(v)
    real, dimension(:), intent(in) :: v
    integer i
    ! THIS IS THE RIGHT WAY
    real :: ke
    ke = 0.
    do i = 1, size(v)
        ke = ke + v(i)**2
    enddo
    kinetic_energy2 = .5*ke
end function kinetic_energy2
</code></pre>
<p><strong>解释</strong></p>
<p>声明时初始化的局部变量具有隐式<code>save</code>属性。<code>ke</code>仅在<strong>第一次</strong>调用函数时初始化。在后续调用中，保留旧的<code>ke</code>值。
为了避免混淆，最好将<code>save</code>属性显式地添加到这些本地初始化的变量中，即使看起来是多余的。</p>
<h2 id="调用fortran-90-风格的子程序"><a class="header" href="#调用fortran-90-风格的子程序">调用Fortran 90 风格的子程序</a></h2>
<pre><code class="language-fortran">program main
    real, dimension(5) :: x

    x = 0.
    ! THIS IS WRONG
    call incb(x)
    print *, x

end program main

subroutine incb(a)
    ! this is a fortran90 style subroutine
    real, dimension(:) :: a
    a = a + 1.
end subroutine incb
</code></pre>
<p><strong>解释</strong></p>
<p>子例程<code>incb</code>使用<code>Fortran 90</code>中的假定形状数组(包含维度(:))。此类例程必须位于模块<code>module</code>中，或者在使用它们的任何地方都有一个显式接口。</p>
<p>调用此类过程的一个正确方法是使用显式接口，如下所示：</p>
<pre><code class="language-fortran">program main
    real, dimension(5) :: x

    ! THIS IS THE RIGHT WAY
    interface
        subroutine incb(a)
        real, dimension(:) :: a
        end subroutine incb
    end interface

    x = 0.
    call incb(x)
    print *, x

end program main

subroutine incb(a)
    ! this is a fortran90 style subroutine
    real, dimension(:) :: a
    a = a + 1.
end subroutine incb
</code></pre>
<p>如果例程位于模块中，则会自动生成接口，无需显式编写。</p>
<pre><code class="language-fortran">! THIS IS ANOTHER RIGHT WAY
module inc
contains
    subroutine incb(a)
        ! this is a fortran90 style subroutine
        real, dimension(:) :: a
        a = a + 1.
    end subroutine incb
end module inc

program main
    use inc
    real, dimension(5) :: x

    x = 0.
    call incb(x)
    print *, x

end program main
</code></pre>
<p>如果使用接口，接口必须与实际的函数匹配。</p>
<h2 id="fortran77-风格的接口"><a class="header" href="#fortran77-风格的接口">Fortran77 风格的接口</a></h2>
<pre><code class="language-fortran">      program main
      real, dimension(5) :: x

! interface to Fortran 77 style routine
      interface
         subroutine inca(a,n)
         integer :: n
! THIS IS THE WRONG WAY
         real, dimension(:) :: a
! THIS IS THE RIGHT WAY
         real, dimension(n) :: a
         end subroutine inca
      end interface

      x = 0.
      call inca(x,5)
      print *, x

      end program main

      subroutine inca(a,n)
! this is a fortran77 style subroutine
      dimension a(n)
      do 10 j = 1, n
      a(j) = a(j) + 1.
   10 continue
      return
      end
</code></pre>
<p><strong>解释</strong></p>
<p>接口声明必须始终与实际的子例程声明相匹配。在本例中，接口语句引用Fortran 90样式的假定形状数组。实际的子例程引用Fortran 77显式形状数组。这里的教训是：Fortran 77风格例程的接口必须只使用Fortran 77风格的构造。
在本例中，允许完全省略接口，因为没有接口的例程在默认情况下被视为Fortran77样式的例程。但是，如果忽略了接口，编译器将<strong>不再检查调用过程的参数是否与接口中列出的参数一致</strong>。</p>
<h2 id="函数重载"><a class="header" href="#函数重载">函数重载</a></h2>
<p>Fortran 90允许对不同的函数使用相同的函数名，只要函数的参数不同。人们会认为下面的函数<code>first_sub</code>和<code>second_sub</code>是不同的，因为在<code>first_sub</code>中，第一个参数是实数，第二个参数是整数，而在<code>second_sub</code>中，参数是相反的。实际上并不是这样。</p>
<pre><code class="language-fortran">interface first_or_second
    module procedure first_sub, second_sub
end interface

subroutine first_sub(a,i)
    real :: a
    integer :: i
    ...
end subroutine first_sub
!
subroutine second_sub(i,a)
    integer :: i
    real :: a
    ...
end subroutine second_sub
</code></pre>
<p><strong>解释</strong></p>
<p>原因是Fortran 90允许按名称（关键字）参数调用过程。</p>
<pre><code class="language-fortran">real :: b
integer :: n
call first_or_second(i=n,a=b)
</code></pre>
<p>该方法将不起作用，因为当按关键字调用时，<code>first_sub</code>和<code>second_sub</code>无法区分，</p>
<pre><code class="language-fortran">call first_sub(i=n,a=b)
call second_sub(i=n,a=b)
</code></pre>
<p>因此不能定义通用函数。通用函数必须能够按类型和名称区分其参数。
解决方案是不要在两个过程中使用相同的虚参名称。例如，以下方法可行：</p>
<pre><code class="language-fortran">subroutine second_sub(i,aa)
    integer :: i
    real :: aa
    ...
end subroutine second_sub
</code></pre>
<h2 id="可分配数组自动分配"><a class="header" href="#可分配数组自动分配">可分配数组自动分配</a></h2>
<p>Fortran 2003之后的标准允许对可分配数组自动分配，这个特性可能为开发者带来方便，同时也带来一些隐藏的bug</p>
<pre><code class="language-fortran">program alloc
    implicit none
    integer,allocatable::a(:)
    integer::b(4)
    a=[1,2]
    write(*,*)size(a)
    a=[a,3]
    write(*,*)size(a)
    a=b+1
    write(*,*)size(a)
end program alloc

</code></pre>
<p><strong>解释</strong></p>
<pre><code class="language-fortran">    a=[1,2]! 1,此时a数组自动分配，大小为2
    a=[a,3]! 2,此时数组自动追加元素，大小为3
    a=b+1  ! 3,此时由于b+1得到一个大小为4的数组，a会被重新分配，所以大小为4
</code></pre>
<p>在计算中，第3种情况由于重新分配数组可能带来一些bug，可以利用如下的办法解决</p>
<pre><code class="language-fortran">    a(:)=b+1 
</code></pre>
<p>此时，编译器会检查数组两边大小是否匹配，然后抛出错误。</p>
<h2 id="浮点数精度的问题"><a class="header" href="#浮点数精度的问题">浮点数精度的问题</a></h2>
<p>Fortran中默认的类型是<code>real</code>单精度,因此对于一个常数，默认只具有单精度，即7位有效数字</p>
<pre><code class="language-fortran">    real(kind=8)::a
    a=1.3
    write(*,*)a
</code></pre>
<p>此时，虽然a是双精度，但是由于<code>1.3</code>只能保持单精度，所以赋值之后得到的结果为<code>1.29999995231628</code>而非<code>1.30000000000000</code>。
所以在程序中，<strong>需要使用对应精度的常数</strong></p>
<pre><code class="language-fortran">    real(kind=8)::a
    a=1.3d0
    write(*,*)a
    a=1.3_8
    write(*,*)a
</code></pre>
<p>两者均可。</p>
<p>同理，在计算的时候也需要注意这一点</p>
<pre><code class="language-fortran">    real(kind=8)::a,b
    a=1.3d0
    b=a*1.4 !精度不足 
    write(*,*)b !1.81999996900558
    b=a*1.4d0
    write(*,*)b !1.82000000000000
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../最佳实践/类型重塑.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../在Windows中进行Fortran编程/说明.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../最佳实践/类型重塑.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../在Windows中进行Fortran编程/说明.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
